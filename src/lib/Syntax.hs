-- Copyright 2019 Google LLC
--
-- Use of this source code is governed by a BSD-style
-- license that can be found in the LICENSE file or at
-- https://developers.google.com/open-source/licenses/bsd

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StrictData #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE PatternSynonyms #-}

module Syntax (
    Type, Kind, BaseType (..), Effect, EffectName (..), EffectRow (..),
    ClassName (..), TyQual (..), SrcPos, Var, Binder, Block (..), Decl (..),
    Expr (..), Atom (..), ArrowP (..), Arrow, PrimTC (..), Abs (..),
    PrimExpr (..), PrimCon (..), LitVal (..), PrimEffect (..), PrimOp (..),
    PrimHof (..), LamExpr, PiType, WithSrc (..), srcPos,
    ScalarBinOp (..), ScalarUnOp (..), CmpOp (..), SourceBlock (..),
    ReachedEOF, SourceBlock' (..), TypeEnv, SubstEnv, Scope, CmdName (..),
    Val, TopEnv (..), Op, Con, Hof, TC, Module (..), ImpFunction (..),
    ImpProg (..), ImpStatement, ImpInstr (..), IExpr (..), IVal, IPrimOp,
    IVar, IType (..), ArrayType, SetVal (..), MonMap (..), LitProg,
    ScalarTableType, ScalarTableVar,
    SrcCtx, Result (..), Output (..), OutFormat (..), DataFormat (..),
    Err (..), ErrType (..), Except, throw, throwIf, modifyErr, addContext,
    addSrcContext, catchIOExcept, liftEitherIO, (-->), (--@), (==>),
    sourceBlockBoundVars, PassName (..), parsePassName,
    freeVars, freeUVars, HasVars, strToName, nameToStr, showPrimName, Vars,
    monMapSingle, monMapLookup, newEnv, Direction (..), ArrayRef, Array, Limit (..),
    UExpr, UExpr' (..), UType, UBinder, UPiBinder, UVar,
    UPat, UPat', PatP, PatP' (..), UModule (..), UDecl (..), UArrow, arrowEff,
    subst, deShadow, scopelessSubst, absArgType, applyAbs, makeAbs, freshSkolemVar,
    mkConsList, mkConsListTy, fromConsList, fromConsListTy, extendEffRow,
    scalarTableBaseType, varType, isTabTy,
    pattern IntLitExpr, pattern RealLitExpr,
    pattern IntVal, pattern UnitTy, pattern PairTy,
    pattern FixedIntRange, pattern RefTy, pattern BoolTy, pattern IntTy,
    pattern RealTy, pattern SumTy, pattern BaseTy, pattern UnitVal,
    pattern PairVal, pattern SumVal, pattern PureArrow, pattern ArrayVal,
    pattern RealVal, pattern BoolVal, pattern TyKind,
    pattern TabTy, pattern TabTyAbs, pattern TabVal, pattern TabValA,
    pattern Pure, pattern BinaryFunTy, pattern BinaryFunVal,
    pattern EffKind, pattern JArrayTy, pattern ArrayTy)
  where

import qualified Data.Map.Strict as M
import Control.Exception hiding (throw)
import Control.Monad.Fail
import Control.Monad.Identity
import Control.Monad.Writer
import Control.Monad.Except hiding (Except)
import qualified Data.Vector.Storable as V
import Data.Foldable (fold)
import Data.List (sort)
import Data.Tuple (swap)
import GHC.Generics

import Cat
import Env
import Array

-- === core IR ===

data Atom = Var Var
          | Lam LamExpr
          | Pi  PiType
          | Con Con
          | TC  TC
          | Eff EffectRow
            deriving (Show, Eq, Generic)

data Expr = App Atom Atom
          | Atom Atom
          | Op  Op
          | Hof Hof
            deriving (Show, Eq, Generic)

data Decl  = Let Binder Expr    deriving (Show, Eq, Generic)
data Block = Block [Decl] Expr  deriving (Show, Eq, Generic)

type Var    = VarP Type
type Binder = VarP Type

data Abs a = Abs Binder a  deriving (Show, Generic, Functor, Foldable, Traversable)
type LamExpr = Abs (Arrow, Block)
type PiType  = Abs (Arrow, Type)

type Arrow = ArrowP EffectRow
data ArrowP eff = PlainArrow eff
                | ImplicitArrow
                | TabArrow
                | LinArrow
                  deriving (Show, Eq, Generic, Functor, Foldable, Traversable)

type Val  = Atom
type Type = Atom
type Kind = Type

type TC  = PrimTC  Atom
type Con = PrimCon Atom
type Op  = PrimOp  Atom
type Hof = PrimHof Atom

data TopEnv = TopEnv SubstEnv
              deriving (Show, Eq, Generic)

type TypeEnv = Env Type
data Module = Module (Maybe BlockId) [Var] [Var] Block  deriving (Show, Eq)

-- A subset of Type generated by the following grammar:
-- data ScalarTableType = TabType (Pi ScalarTableType) | Scalar BaseType
type ScalarTableType = Type
type ScalarTableVar  = VarP ScalarTableType

scalarTableBaseType :: ScalarTableType -> BaseType
scalarTableBaseType t = case t of
  TabTy _ a -> scalarTableBaseType a
  BaseTy b  -> b
  _         -> error $ "Not a scalar table: " ++ show t

-- === front-end language AST ===

type UExpr = WithSrc UExpr'
data UExpr' = UVar UVar
            | ULam UBinder UArrow UExpr
            | UPi  UPiBinder Arrow UType
            | UApp UArrow UExpr UExpr
            | UDecl UDecl UExpr
            | UFor Direction UBinder UExpr
            | UHole
            | UTabCon [UExpr] (Maybe UExpr)
            | UIndexRange (Limit UExpr) (Limit UExpr)
            | UPrimExpr (PrimExpr Name)
              deriving (Show, Eq, Generic)

data UDecl = ULet UBinder UExpr  deriving (Show, Eq, Generic)

type UType  = UExpr
type UArrow = ArrowP ()
type UVar   = VarP ()

type UPat    = PatP  UVar
type UPat'   = PatP' UVar
type UBinder   = (UPat, Maybe UType)
type UPiBinder = VarP UType

data UModule = UModule [Name] [Name] [UDecl]  deriving (Show, Eq)
type SrcPos = (Int, Int)

type PatP  a = WithSrc (PatP' a)
data PatP' a = PatBind a
             | PatPair (PatP a) (PatP a)
             | PatUnit  deriving (Show, Eq, Functor, Foldable, Traversable)

data WithSrc a = WithSrc SrcPos a
                 deriving (Show, Eq, Functor, Foldable, Traversable)

srcPos :: WithSrc a -> SrcPos
srcPos (WithSrc pos _) = pos

-- === primitive constructors and operators ===

data PrimExpr e =
        TCExpr  (PrimTC  e)
      | ConExpr (PrimCon e)
      | OpExpr  (PrimOp  e)
      | HofExpr (PrimHof e)
        deriving (Show, Eq, Generic, Functor, Foldable, Traversable)

data PrimTC e =
        BaseType  BaseType
      | ArrayType e         -- A pointer to memory storing a ScalarTableType value
      | IntRange e e
      | IndexRange e (Limit e) (Limit e)
      | PairType e e
      | UnitType
      | SumType e e
      | RefType e e
      | TypeKind
      | EffectRowKind
        -- NOTE: This is just a hack so that we can construct an Atom from an Imp or Jax expression.
        --       In the future it might make sense to parametrize Atoms by the types
        --       of values they can hold.
        -- XXX: This one can temporarily also appear in the fully evaluated terms in TopLevel.
      | JArrayType [Int] BaseType
        deriving (Show, Eq, Generic, Functor, Foldable, Traversable)

data PrimCon e =
        Lit LitVal
      | ArrayLit e Array  -- Used to store results of module evaluation
      | AnyValue e        -- Produces an arbitrary value of a given type
      | SumCon e e e      -- (bool constructor tag (True is Left), left value, right value)
      | PairCon e e
      | UnitCon
      | RefCon e e
      | AsIdx e e         -- Construct an index from its ordinal index (zero-based int)
      | Todo e
        deriving (Show, Eq, Generic, Functor, Foldable, Traversable)

data PrimOp e =
        Fst e
      | Snd e
      | SumGet e Bool
      | SumTag e
      | TabCon e [e]                 -- table type elements
      | ScalarBinOp ScalarBinOp e e
      | ScalarUnOp ScalarUnOp e
      | Select e e e                 -- predicate, val-if-true, val-if-false
      | PrimEffect e (PrimEffect e)
      | IndexRef e e
      | FFICall String BaseType [e]
      | Inject e
      | ArrayOffset e e e            -- Second argument is the index for type checking,
                                     -- Third argument is the linear offset for evaluation
      | ArrayLoad e
      -- Typeclass operations
      -- Eq and Ord (should get eliminated during simplification)
      | Cmp CmpOp e e
      -- Idx (survives simplification, because we allow it to be backend-dependent)
      | IntAsIndex e e   -- index set, ordinal index
      | IndexAsInt e
      | IdxSetSize e
        deriving (Show, Eq, Generic, Functor, Foldable, Traversable)

data PrimHof e =
        For Direction e
      | SumCase e e e
      | RunReader e e
      | RunWriter e
      | RunState  e e
      | Linearize e
      | Transpose e
        deriving (Show, Eq, Generic, Functor, Foldable, Traversable)

data PrimEffect e = MAsk | MTell e | MGet | MPut e
    deriving (Show, Eq, Generic, Functor, Foldable, Traversable)

data ScalarBinOp = IAdd | ISub | IMul | IDiv | ICmp CmpOp
                 | FAdd | FSub | FMul | FDiv | FCmp CmpOp | Pow
                 | And | Or | Rem
                   deriving (Show, Eq, Generic)

data ScalarUnOp = Not | FNeg | IntToReal | BoolToInt | UnsafeIntToBool
                  deriving (Show, Eq, Generic)

data CmpOp = Less | Greater | Equal | LessEqual | GreaterEqual
             deriving (Show, Eq, Generic)

data Direction = Fwd | Rev  deriving (Show, Eq, Generic)

data Limit a = InclusiveLim a
             | ExclusiveLim a
             | Unlimited
               deriving (Show, Eq, Generic, Functor, Foldable, Traversable)

data ClassName = Data | VSpace | IdxSet | Eq | Ord deriving (Show, Eq, Generic)

data TyQual = TyQual Var ClassName  deriving (Show, Eq, Generic)

type PrimName = PrimExpr ()

strToName :: String -> Maybe PrimName
strToName s = M.lookup s builtinNames

nameToStr :: PrimName -> String
nameToStr prim = case lookup prim $ map swap $ M.toList builtinNames of
  Just s  -> s
  Nothing -> show prim

showPrimName :: PrimExpr e -> String
showPrimName prim = nameToStr $ fmap (const ()) prim

-- === effects ===

type Effect = (EffectName, Name)
data EffectRow = EffectRow [Effect] (Maybe Name)
                 deriving (Show, Generic)
data EffectName = Reader | Writer | State  deriving (Show, Eq, Ord, Generic)

pattern Pure :: EffectRow
pattern Pure = EffectRow [] Nothing

instance Eq EffectRow where
  EffectRow effs t == EffectRow effs' t' =
    sort effs == sort effs' && t == t'

-- === top-level constructs ===

data SourceBlock = SourceBlock
  { sbLine     :: Int
  , sbOffset   :: Int
  , sbText     :: String
  , sbContents :: SourceBlock'
  , sbId       :: Maybe BlockId }  deriving (Show)

type BlockId = Int
type ReachedEOF = Bool
data SourceBlock' = RunModule UModule
                  | Command CmdName (Name, UModule)
                  | GetNameType Name
                  | IncludeSourceFile String
                  | LoadData UBinder DataFormat String
                  | ProseBlock String
                  | CommentLine
                  | EmptyLines
                  | UnParseable ReachedEOF String
                    deriving (Show, Eq, Generic)

data CmdName = GetType | ShowPasses | ShowPass PassName
             | TimeIt | EvalExpr OutFormat | Dump DataFormat String
                deriving  (Show, Eq, Generic)

-- === imperative IR ===

data ImpFunction = ImpFunction [ScalarTableVar] [ScalarTableVar] ImpProg  -- destinations first
                   deriving (Show, Eq)
newtype ImpProg = ImpProg [ImpStatement]
                  deriving (Show, Eq, Generic, Semigroup, Monoid)
type ImpStatement = (Maybe IVar, ImpInstr)

data ImpInstr = Load  IExpr
              | Store IExpr IExpr           -- Destination first
              | Alloc ScalarTableType Size  -- Second argument is the size of the table
              | Free IVar
              | IOffset IExpr Index IExpr   -- Second argument is the index for type checking
                                            -- Third argument is the linear offset for code generation
              | Loop Direction IVar Size ImpProg
              | IPrimOp IPrimOp
                deriving (Show, Eq)

data IExpr = ILit LitVal
           | IVar IVar
             deriving (Show, Eq)

type IPrimOp = PrimOp IExpr
type IVal = IExpr  -- only ILit and IRef constructors
type IVar = VarP IType
data IType = IValType BaseType
           | IRefType ScalarTableType -- This represents ArrayType (ScalarTableType)
             deriving (Show, Eq)

type Size  = IExpr
type Index = IExpr

-- === some handy monoids ===

data SetVal a = Set a | NotSet
newtype MonMap k v = MonMap (M.Map k v)  deriving (Show, Eq)

instance Semigroup (SetVal a) where
  x <> NotSet = x
  _ <> Set x  = Set x

instance Monoid (SetVal a) where
  mempty = NotSet

instance (Ord k, Semigroup v) => Semigroup (MonMap k v) where
  MonMap m <> MonMap m' = MonMap $ M.unionWith (<>) m m'

instance (Ord k, Semigroup v) => Monoid (MonMap k v) where
  mempty = MonMap mempty

monMapSingle :: k -> v -> MonMap k v
monMapSingle k v = MonMap (M.singleton k v)

monMapLookup :: (Monoid v, Ord k) => MonMap k v -> k -> v
monMapLookup (MonMap m) k = case M.lookup k m of Nothing -> mempty
                                                 Just v  -> v

-- === passes ===

data PassName = Parse | TypePass | NormPass | SimpPass | ImpPass | JitPass
              | Flops | LLVMOpt | AsmPass | JAXPass | JAXSimpPass | LLVMEval
              | JaxprAndHLO
                deriving (Ord, Eq, Bounded, Enum)

passNameMap :: M.Map String PassName
passNameMap = buildNameMap

parsePassName :: String -> Maybe PassName
parsePassName s = M.lookup s passNameMap

instance Show PassName where
  show p = case p of
    Parse    -> "parse" ; TypePass -> "typed"   ; NormPass -> "norm"
    SimpPass -> "simp"  ; ImpPass  -> "imp"     ; JitPass  -> "llvm"
    Flops    -> "flops" ; LLVMOpt  -> "llvmopt" ; AsmPass  -> "asm"
    JAXPass  -> "jax"   ; JAXSimpPass -> "jsimp";
    LLVMEval -> "llvmeval" ; JaxprAndHLO -> "jaxprhlo";

-- TODO: consider using this for builtins too
buildNameMap :: (Show a, Enum a, Bounded a) => M.Map String a
buildNameMap = M.fromList [(show x, x) | x <- [minBound..maxBound]]

-- === outputs ===

type LitProg = [(SourceBlock, Result)]
type SrcCtx = Maybe SrcPos
data Result = Result [Output] (Except ())  deriving (Show, Eq)

data Output = TextOut String
            | HeatmapOut Int Int (V.Vector Double)
            | ScatterOut (V.Vector Double) (V.Vector Double)
            | PassInfo PassName String
            | MiscLog String
              deriving (Show, Eq, Generic)

data OutFormat = Printed | Heatmap | Scatter   deriving (Show, Eq, Generic)
data DataFormat = DexObject | DexBinaryObject  deriving (Show, Eq, Generic)

data Err = Err ErrType SrcCtx String  deriving (Show, Eq)
instance Exception Err

data ErrType = NoErr
             | ParseErr
             | TypeErr
             | KindErr
             | LinErr
             | UnboundVarErr
             | RepeatedVarErr
             | CompilerErr
             | NotImplementedErr
             | DataIOErr
             | MiscErr
  deriving (Show, Eq)

type Except = Either Err

throw :: MonadError Err m => ErrType -> String -> m a
throw e s = throwError $ Err e Nothing s

throwIf :: MonadError Err m => Bool -> ErrType -> String -> m ()
throwIf True  e s = throw e s
throwIf False _ _ = return ()

modifyErr :: MonadError e m => m a -> (e -> e) -> m a
modifyErr m f = catchError m $ \e -> throwError (f e)

addContext :: MonadError Err m => String -> m a -> m a
addContext s m = modifyErr m $ \(Err e p s') -> Err e p (s' ++ s)

addSrcContext :: MonadError Err m => SrcCtx -> m a -> m a
addSrcContext ctx m = modifyErr m updateErr
  where
    updateErr :: Err -> Err
    updateErr (Err e ctx' s) = case ctx' of Nothing -> Err e ctx  s
                                            Just _  -> Err e ctx' s

catchIOExcept :: (MonadIO m , MonadError Err m) => IO a -> m a
catchIOExcept m = (liftIO >=> liftEither) $ (liftM Right m) `catches`
  [ Handler $ \(e::Err)           -> return $ Left e
  , Handler $ \(e::IOError)       -> return $ Left $ Err DataIOErr   Nothing $ show e
  , Handler $ \(e::SomeException) -> return $ Left $ Err CompilerErr Nothing $ show e
  ]

liftEitherIO :: (Exception e, MonadIO m) => Either e a -> m a
liftEitherIO (Left err) = liftIO $ throwIO err
liftEitherIO (Right x ) = return x

instance MonadFail (Either Err) where
  fail s = Left $ Err CompilerErr Nothing s

-- === UExpr free variables ===

type UVars = Env ()

class HasUVars a where
  freeUVars :: a -> UVars

instance HasUVars a => HasUVars (WithSrc a) where
  freeUVars (WithSrc _ e) = freeUVars e

instance HasUVars UExpr' where
  freeUVars expr = case expr of
    UVar v -> v@>()
    ULam b _ body -> uAbsFreeVars b body
    UPi b arr ty ->
      freeUVars (varAnn b) <>
      ((freeUVars arr <> freeUVars ty) `envDiff` (b@>()))
    -- TODO: maybe distinguish table arrow application
    -- (otherwise `x.i` and `x i` are the same)
    UApp _ f x -> freeUVars f <> freeUVars x
    UDecl (ULet b rhs) body -> freeUVars rhs <> uAbsFreeVars b body
    UFor _ b body -> uAbsFreeVars b body
    UHole -> mempty
    UTabCon xs n -> foldMap freeUVars xs <> foldMap freeUVars n
    UIndexRange low high -> foldMap freeUVars low <> foldMap freeUVars high
    UPrimExpr _ -> mempty

instance HasUVars UDecl where
  freeUVars (ULet p expr) = uBinderFreeVars p <> freeUVars expr

instance HasUVars SourceBlock where
  freeUVars block = case sbContents block of
    RunModule (   UModule vs _ _) -> foldMap nameAsEnv vs
    Command _ (_, UModule vs _ _) -> foldMap nameAsEnv vs
    GetNameType v                 -> (v:>()) @> ()
    _ -> mempty

instance HasUVars EffectRow where
  freeUVars (EffectRow effs tailVar) =
    foldMap (nameAsEnv . snd) effs <> foldMap nameAsEnv tailVar

instance HasUVars eff => HasUVars (ArrowP eff) where
  freeUVars (PlainArrow eff) = freeUVars eff
  freeUVars _ = mempty

uAbsFreeVars :: UBinder -> UExpr -> UVars
uAbsFreeVars (WithSrc _ pat, ann) body =
  foldMap freeUVars ann <> (freeUVars body `envDiff` foldMap (@>()) pat)

uBinderFreeVars :: UBinder -> UVars
uBinderFreeVars (_, ann) = foldMap freeUVars ann

sourceBlockBoundVars :: SourceBlock -> UVars
sourceBlockBoundVars block = case sbContents block of
  RunModule (UModule _ vs _)    -> foldMap nameAsEnv vs
  LoadData (WithSrc _ p, _) _ _ -> foldMap (@>()) p
  _                             -> mempty

nameAsEnv :: Name -> UVars
nameAsEnv v = (v:>())@>()

-- === Expr free variables and substitutions ===

type Vars = TypeEnv
type SubstEnv = Env Atom
type Scope    = Env (Maybe Expr)
type ScopedSubstEnv = (SubstEnv, Scope)

scopelessSubst :: HasVars a => SubstEnv -> a -> a
scopelessSubst env x = subst (env, scope) x
  where scope = fmap (const Nothing) $
          foldMap freeVars env <> (freeVars x `envDiff` env)

class HasVars a where
  freeVars :: a -> Vars
  subst :: ScopedSubstEnv -> a -> a

instance (Show a, HasVars a, Eq a) => Eq (Abs a) where
  Abs (NoName:>a) b == Abs (NoName:>a') b' = a == a' && b == b'
  ab@(Abs (_:>a) _) == ab'@(Abs (_:>a') _) =
    a == a' && applyAbs ab v == applyAbs ab' v
    where v = Var $ freshSkolemVar (ab, ab') a

freshSkolemVar :: HasVars a => a -> Type -> Var
freshSkolemVar x ty = rename (rawName Skolem "skol" :> ty) (freeVars x)

-- NOTE: We don't have an instance for VarP, because it's used to represent
--       both binders and regular variables, but each requires different treatment
freeBinderTypeVars :: Var -> Vars
freeBinderTypeVars (_ :> t) = freeVars t

applyAbs :: HasVars a => Abs a -> Atom -> a
applyAbs (Abs v body) x = scopelessSubst (v@>x) body

makeAbs :: HasVars a => Var -> a -> Abs a
makeAbs v body | v `isin` freeVars body = Abs v body
               | otherwise              = Abs (NoName:> varAnn v) body

absArgType :: Abs a -> Type
absArgType (Abs (_:>ty) _) = ty

varFreeVars :: Var -> Vars
varFreeVars v@(_ :> t) = bind v <> freeVars t

bind :: VarP a -> Env a
bind v@(_:>ty) = v @> ty

newEnv :: [VarP ann] -> [a] -> Env a
newEnv vs xs = fold $ zipWith (@>) vs xs

instance HasVars Arrow where
  freeVars arrow = case arrow of
    PlainArrow eff -> freeVars eff
    _ -> mempty

  subst env arrow = case arrow of
    PlainArrow eff -> PlainArrow $ subst env eff
    _ -> arrow

arrowEff :: Arrow -> EffectRow
arrowEff (PlainArrow eff) = eff
arrowEff _ = Pure

substVar :: (SubstEnv, Scope) -> Var -> Atom
substVar env@(sub, scope) v = case envLookup sub v of
  Nothing -> Var $ fmap (subst env) v
  Just x' -> deShadow x' scope

deShadow :: HasVars a => a -> Scope -> a
deShadow x scope = subst (mempty, scope) x

instance HasVars Expr where
  freeVars expr = case expr of
    App f x -> freeVars f <> freeVars x
    Atom x  -> freeVars x
    Op  e   -> foldMap freeVars e
    Hof e   -> foldMap freeVars e

  subst env expr = case expr of
    App f x -> App (subst env f) (subst env x)
    Atom x  -> Atom $ subst env x
    Op  e   -> Op  $ fmap (subst env) e
    Hof e   -> Hof $ fmap (subst env) e

instance HasVars Decl where
  freeVars (Let bs expr) = foldMap freeVars bs <> freeVars expr
  subst env (Let (v:>ty) bound) = Let (v:> subst env ty) (subst env bound)

instance HasVars Block where
  freeVars (Block [] result) = freeVars result
  freeVars (Block (decl@(Let b _):decls) result) =
    freeVars decl <> (freeVars body `envDiff` (b@>()))
    where body = Block decls result

  subst env (Block decls result) = do
    let (decls', env') = catMap substDecl env decls
    let result' = subst (env <> env') result
    Block decls' result'

instance HasVars Atom where
  freeVars atom = case atom of
    Var v   -> varFreeVars v
    Lam lam -> freeVars lam
    Pi  ty  -> freeVars ty
    Con con -> foldMap freeVars con
    TC  tc  -> foldMap freeVars tc
    Eff eff -> freeVars eff

  subst env atom = case atom of
    Var v   -> substVar env v
    Lam lam -> Lam $ subst env lam
    Pi  ty  -> Pi  $ subst env ty
    TC  tc  -> TC  $ fmap (subst env) tc
    Con con -> Con $ fmap (subst env) con
    Eff eff -> Eff $ subst env eff

instance HasVars EffectRow where
  freeVars (EffectRow row t) =
       foldMap (\(_,v) -> (v:>())@>TyKind) row
    <> foldMap (\v     -> (v:>())@>EffKind) t

  subst (env, _) (EffectRow row t) = extendEffRow
    (fmap (\(effName, v) -> (effName, substName env v)) row)
    (substEffTail env t)

substEffTail :: SubstEnv -> Maybe Name -> EffectRow
substEffTail _ Nothing = EffectRow [] Nothing
substEffTail env (Just v) = case envLookup env (v:>()) of
  Nothing -> EffectRow [] (Just v)
  Just (Var (v':>_)) -> EffectRow [] (Just v')
  Just (Eff r) -> r
  _ -> error "Not a valid effect substitution"

substName :: SubstEnv -> Name -> Name
substName env v = case envLookup env (v:>()) of
  Nothing -> v
  Just (Var (v':>_)) -> v'
  _ -> error "Should only substitute with a name"

extendEffRow :: [Effect] -> EffectRow -> EffectRow
extendEffRow effs (EffectRow effs' t) = EffectRow (effs <> effs') t

instance HasVars a => HasVars (Abs a) where
  freeVars (Abs b body) =
    freeBinderTypeVars b <> (freeVars body `envDiff` (b@>()))

  subst env (Abs (v:>ty) body) = Abs b body'
    where (b, env') = refreshBinder env (v:> subst env ty)
          body' = subst (env <> env') body

substDecl :: ScopedSubstEnv -> Decl -> (Decl, ScopedSubstEnv)
substDecl env (Let (v:>ty) bound) = (Let b (subst env bound), env')
  where (b, env') = refreshBinder env (v:> subst env ty)

refreshBinder :: ScopedSubstEnv -> Var -> (Var, ScopedSubstEnv)
refreshBinder (_, scope) b = (b', env')
  where b' = rename b scope
        env' = (b@>Var b', b'@>Nothing)

instance HasVars TopEnv where
  freeVars (TopEnv e1) = freeVars e1
  subst = error "not implemented"

instance HasVars () where
  freeVars () = mempty
  subst _ () = ()

instance (HasVars a, HasVars b) => HasVars (a, b) where
  freeVars (x, y) = freeVars x <> freeVars y
  subst env (x, y) = (subst env x, subst env y)

instance (HasVars a, HasVars b) => HasVars (Either a b)where
  freeVars (Left  x) = freeVars x
  freeVars (Right x) = freeVars x
  subst = error "not implemented"

instance HasVars a => HasVars (Maybe a) where
  freeVars x = foldMap freeVars x
  subst env x = fmap (subst env) x

instance HasVars a => HasVars (Env a) where
  freeVars x = foldMap freeVars x
  subst env x = fmap (subst env) x

instance HasVars a => HasVars [a] where
  freeVars x = foldMap freeVars x
  subst env x = fmap (subst env) x

instance Semigroup TopEnv where
  TopEnv e1 <> TopEnv e1'= TopEnv (e1 <> e1')

instance Monoid TopEnv where
  mempty = TopEnv mempty

instance Eq SourceBlock where
  x == y = sbText x == sbText y

instance Ord SourceBlock where
  compare x y = compare (sbText x) (sbText y)

-- === Synonyms ===

varType :: Var -> Type
varType = varAnn

infixr 1 -->
infixr 1 --@
infixr 2 ==>

(-->) :: Type -> Type -> Type
a --> b = Pi (Abs (NoName:>a) (PureArrow, b))

(--@) :: Type -> Type -> Type
a --@ b = Pi (Abs (NoName:>a) (LinArrow, b))

(==>) :: Type -> Type -> Type
a ==> b = Pi (Abs (NoName:>a) (TabArrow, b))

pattern IntLitExpr :: Int -> UExpr'
pattern IntLitExpr x = UPrimExpr (ConExpr (Lit (IntLit x)))

pattern RealLitExpr :: Double -> UExpr'
pattern RealLitExpr x = UPrimExpr (ConExpr (Lit (RealLit x)))

pattern IntVal :: Int -> Atom
pattern IntVal x = Con (Lit (IntLit x))

pattern RealVal :: Double -> Atom
pattern RealVal x = Con (Lit (RealLit x))

pattern BoolVal :: Bool -> Atom
pattern BoolVal x = Con (Lit (BoolLit x))

pattern ArrayVal :: Type -> Array -> Atom
pattern ArrayVal t arr = Con (ArrayLit t arr)

pattern SumVal :: Atom -> Atom -> Atom -> Atom
pattern SumVal t l r = Con (SumCon t l r)

pattern PairVal :: Atom -> Atom -> Atom
pattern PairVal x y = Con (PairCon x y)

pattern PairTy :: Type -> Type -> Type
pattern PairTy x y = TC (PairType x y)

pattern UnitVal :: Atom
pattern UnitVal = Con UnitCon

pattern UnitTy :: Type
pattern UnitTy = TC UnitType

pattern JArrayTy :: [Int] -> BaseType -> Type
pattern JArrayTy shape b = TC (JArrayType shape b)

pattern BaseTy :: BaseType -> Type
pattern BaseTy b = TC (BaseType b)

pattern SumTy :: Type -> Type -> Type
pattern SumTy l r = TC (SumType l r)

pattern RefTy :: Atom -> Type -> Type
pattern RefTy r a = TC (RefType r a)

pattern IntTy :: Type
pattern IntTy = TC (BaseType IntType)

pattern BoolTy :: Type
pattern BoolTy = TC (BaseType BoolType)

pattern RealTy :: Type
pattern RealTy = TC (BaseType RealType)

pattern TyKind :: Kind
pattern TyKind = TC TypeKind

pattern EffKind :: Kind
pattern EffKind = TC EffectRowKind

pattern FixedIntRange :: Int -> Int -> Type
pattern FixedIntRange low high = TC (IntRange (IntVal low) (IntVal high))

pattern PureArrow :: Arrow
pattern PureArrow = PlainArrow Pure

pattern ArrayTy :: Type -> Type
pattern ArrayTy t = TC (ArrayType t)

pattern TabTy :: Var -> Type -> Type
pattern TabTy v i = Pi (Abs v (TabArrow, i))

pattern TabTyAbs :: PiType -> Type
pattern TabTyAbs a <- Pi a@(Abs _ (TabArrow, _))

pattern TabVal :: Var -> Block -> Atom
pattern TabVal v b = Lam (Abs v (TabArrow, b))

pattern TabValA :: Var -> Atom -> Atom
pattern TabValA v a = Lam (Abs v (TabArrow, (Block [] (Atom a))))

isTabTy :: Type -> Bool
isTabTy (TabTy _ _) = True
isTabTy _ = False

mkConsListTy :: [Type] -> Type
mkConsListTy tys = foldr PairTy UnitTy tys

mkConsList :: [Atom] -> Atom
mkConsList xs = foldr PairVal UnitVal xs

fromConsListTy :: MonadError Err m => Type -> m [Type]
fromConsListTy ty = case ty of
  UnitTy         -> return []
  PairTy t rest -> (t:) <$> fromConsListTy rest
  _              -> throw CompilerErr $ "Not a pair or unit: " ++ show ty

fromConsList :: MonadError Err m => Atom -> m [Atom]
fromConsList xs = case xs of
  UnitVal        -> return []
  PairVal x rest -> (x:) <$> fromConsList rest
  _              -> throw CompilerErr $ "Not a pair or unit: " ++ show xs

pattern BinaryFunTy :: Binder -> Binder -> EffectRow -> Type -> Type
pattern BinaryFunTy b1 b2 eff bodyTy =
          Pi (Abs b1 (PureArrow,
          Pi (Abs b2 (PlainArrow eff, bodyTy))))

pattern BinaryFunVal :: Binder -> Binder -> EffectRow -> Block -> Type
pattern BinaryFunVal b1 b2 eff body =
          Lam (Abs b1 (PureArrow, Block [] (Atom (
          Lam (Abs b2 (PlainArrow eff, body))))))

-- TODO: Enable once https://gitlab.haskell.org//ghc/ghc/issues/13363 is fixed...
-- {-# COMPLETE TypeVar, ArrowType, TabTy, Forall, TypeAlias, Effect, NoAnn, TC #-}

-- TODO: Can we derive these generically? Or use Show/Read?
--       (These prelude-only names don't have to be pretty.)
builtinNames :: M.Map String PrimName
builtinNames = M.fromList
  [ ("iadd", binOp IAdd), ("isub", binOp ISub)
  , ("imul", binOp IMul), ("fdiv", binOp FDiv)
  , ("fadd", binOp FAdd), ("fsub", binOp FSub)
  , ("fmul", binOp FMul), ("idiv", binOp IDiv)
  , ("pow" , binOp Pow ), ("rem" , binOp Rem )
  , ("and" , binOp And ), ("or"  , binOp Or  ), ("not" , unOp  Not )
  , ("fneg", unOp  FNeg)
  , ("eq", cmpOp Equal)
  , ("less"    , cmpOp Less   ), ("lessEq"    , cmpOp LessEqual   )
  , ("greater" , cmpOp Greater), ("greaterEq" , cmpOp GreaterEqual)
  , ("True" , ConExpr $ Lit $ BoolLit True)
  , ("False", ConExpr $ Lit $ BoolLit False)
  , ("inttoreal", unOp IntToReal)
  , ("booltoint", unOp BoolToInt)
  , ("asint"       , OpExpr $ IndexAsInt ())
  , ("idxSetSize"  , OpExpr $ IdxSetSize ())
  , ("asidx"       , OpExpr $ IntAsIndex () ())
  , ("select"      , OpExpr $ Select () () ())
  , ("todo"       , ConExpr $ Todo ())
  , ("ask"        , OpExpr $ PrimEffect () $ MAsk)
  , ("tell"       , OpExpr $ PrimEffect () $ MTell ())
  , ("get"        , OpExpr $ PrimEffect () $ MGet)
  , ("put"        , OpExpr $ PrimEffect () $ MPut  ())
  , ("indexRef"   , OpExpr $ IndexRef () ())
  , ("inject"     , OpExpr $ Inject ())
  , ("linearize"       , HofExpr $ Linearize ())
  , ("linearTranspose" , HofExpr $ Transpose ())
  , ("runReader"       , HofExpr $ RunReader () ())
  , ("runWriter"       , HofExpr $ RunWriter    ())
  , ("runState"        , HofExpr $ RunState  () ())
  , ("caseAnalysis"    , HofExpr $ SumCase () () ())
  , ("Int"     , TCExpr $ BaseType IntType)
  , ("Real"    , TCExpr $ BaseType RealType)
  , ("Bool"    , TCExpr $ BaseType BoolType)
  , ("TyKind"  , TCExpr $ TypeKind)
  , ("IntRange", TCExpr $ IntRange () ())
  , ("Ref"     , TCExpr $ RefType () ())
  , ("PairType", TCExpr $ PairType () ())
  , ("SumType" , TCExpr $ SumType () ())
  , ("UnitType", TCExpr $ UnitType)
  , ("EffKind" , TCExpr $ EffectRowKind)
  , ("pair", ConExpr $ PairCon () ())
  , ("fst", OpExpr $ Fst ())
  , ("snd", OpExpr $ Snd ())
  , ("sumCon", ConExpr $ SumCon () () ())
  , ("anyVal", ConExpr $ AnyValue ())
  ]
  where
    binOp op = OpExpr $ ScalarBinOp op () ()
    unOp  op = OpExpr $ ScalarUnOp  op ()
    cmpOp op = OpExpr $ Cmp op () ()
