'# Sets, Set-Indexed Arrays, and Multisets

import sort

'## Monoidal enforcement of uniqueness in sorted lists

def last(xs:n=>a) -> Maybe a given (n|Ix, a) =
  s = size n
  case s == 0 of
    True -> Nothing
    False -> Just xs[unsafe_from_ordinal (unsafe_nat_diff s 1)]

def first(xs:n=>a) -> Maybe a given (n|Ix, a) =
  s = size n
  case s == 0 of
    True -> Nothing
    False -> Just xs[unsafe_from_ordinal 0]

def all_except_last(xs:n=>a) -> List a given (n|Ix, a) =
  shortSize = Fin (size n -| 1)
  allButLast = for i:shortSize. xs[unsafe_from_ordinal (ordinal i)]
  AsList _ allButLast

def all_except_first(xs:n=>a) -> List a given (n|Ix, a) =
  shortSize = Fin (size n -| 1)
  allButFirst = for i:shortSize. xs[unsafe_from_ordinal (1 + ordinal i)]
  (AsList _ allButFirst)

def merge_unique_sorted_lists_with_aux(
    combine_side_info : (side, side)->side,
    xlist:List (a, side),
    ylist:List (a, side)) -> List (a, side) given (a|Eq, side|Data) =
  -- This function is associative, for use in a monoidal reduction.
  -- Assumes all xs are <= all ys.
  -- The element at the end of xs might equal the
  -- element at the beginning of ys.  If so, this
  -- function removes the duplicate when concatenating the lists.
  AsList(nx, xs) = xlist
  AsList(_,  ys) = ylist
  case last xs of
    Nothing -> ylist
    Just last_x -> case first ys of
      Nothing -> xlist
      Just first_y ->
        (last_x_inner, last_x_side) = last_x
        (first_y_inner, first_y_side) = first_y
        case last_x_inner == first_y_inner of
          False -> xlist <> ylist
          True ->
            combined = AsList 1 [(first_y_inner, combine_side_info last_x_side first_y_side)]
            all_except_last xs <> combined <> all_except_first ys

def remove_duplicates_from_sorted(xs:n=>a) -> List a given (n|Ix, a|Eq) =
  -- Special case for ordinary sets, which don't have any side information.
  xlist = for i. AsList(_, [(xs[i], ())])
  ignore = \a b. ()
  AsList(_, set_with_aux) =
    reduce AsList(0, []) (\x y. merge_unique_sorted_lists_with_aux(ignore, x, y)) xlist
  AsList(_, for i. fst set_with_aux[i])


'## Sets

data Set(a|Ord) =
  -- Guaranteed to be in sorted order with unique elements,
  -- as long as no one else uses this constructor.
  -- Instead use the "toSet" function below.
  UnsafeAsSet(n:Nat, elements:(Fin n => a))

def to_set(xs:n=>a) -> Set a given (n|Ix, a|Ord) =
  sorted_xs = sort xs
  AsList(n', sorted_unique_xs) = remove_duplicates_from_sorted sorted_xs
  UnsafeAsSet n' sorted_unique_xs

def set_size(p:Set a) -> Nat given (a|Ord) =
  UnsafeAsSet(n, _) = p
  n

instance Eq(Set a) given (a|Ord)
  def (==)(sx, sy) =
    UnsafeAsSet(_, xs) = sx
    UnsafeAsSet(_, ys) = sy
    (AsList _ xs) == (AsList _ ys)

def set_union(
    sx:Set a,
    sy:Set a
    ) -> Set a given (a|Ord) =
  UnsafeAsSet(nx, xs) = sx
  UnsafeAsSet(ny, ys) = sy
  combined = merge_sorted_tables xs ys
  AsList(n', sorted_unique_xs) = remove_duplicates_from_sorted combined
  UnsafeAsSet _ sorted_unique_xs

def set_intersect(
    sx:Set a,
    sy:Set a
    ) -> Set a given (a|Ord) =
  UnsafeAsSet(nx, xs) = sx
  UnsafeAsSet(ny, ys) = sy
  -- This could be done in O(nx + ny) instead of O(nx log ny).
  isInYs = \x. case search_sorted_exact ys x of
    Just x -> True
    Nothing -> False
  AsList(n', intersection) = filter xs isInYs
  UnsafeAsSet _ intersection


'## Sets as a type, whose inhabitants can index arrays

struct Element(set:(Set a)) given (a|Ord) =
  val: Fin (set_size set)

-- TODO The set argument could be implicit (inferred from the Element
-- type), but maybe it's easier to read if it's explicit.
def member(x:a, set:(Set a)) -> Maybe (Element set) given (a|Ord) =
  UnsafeAsSet(_, elts) = set
  case search_sorted_exact elts x of
    Just i -> Just Element((ordinal i)@_)  -- Should be Just Element(i)
    Nothing -> Nothing

def value(x:Element set) -> a given (a|Ord, set:Set a) =
  UnsafeAsSet(_, elts) = set
  elts[x.val]

instance Ix(Element set) given (a|Ord, set:Set a)
  def size'() = set_size set
  def ordinal(n) = ordinal n.val
  def unsafe_from_ordinal(n) = Element(n@_)

instance Eq(Element set) given (a|Ord, set:Set a)
  def (==)(x, y) = x.val == y.val

instance Ord(Element set) given (a|Ord, set:Set a)
  def (<)(x, y) = x.val < y.val
  def (>)(x, y) = x.val > y.val

'## Multisets

def remove_duplicates_from_sorted_with_counts(xs:n=>(a, Nat)) ->
    List (a, Nat) given (n|Ix, a|Eq|Data) =
  xlists = for i. AsList(1, [xs[i]])
  reduce AsList(_, []) (\x y. merge_unique_sorted_lists_with_aux(\a b. a + b, x, y)) xlists

data Multiset(a|Ord) =
  -- Guaranteed to be in sorted order,
  -- as long as no one else uses this constructor.
  -- Instead use the "to_multiset" function below.
  UnsafeAsMultiset(n:Nat, elements:(Fin n => (a, Nat)))

def to_multiset(xs:n=>a) -> Multiset a given (n|Ix, a|Ord) =
  sorted_xs = sort xs
  sorted_xs_with_1s = for i. (sorted_xs[i], 1)
  AsList(n', unique_xs) = remove_duplicates_from_sorted_with_counts sorted_xs_with_1s
  UnsafeAsMultiset n' unique_xs

instance Eq(Multiset a) given (a|Ord)
  def (==)(sx, sy) =
    UnsafeAsMultiset(_, xs) = sx
    UnsafeAsMultiset(_, ys) = sy
    (AsList _ xs) == (AsList _ ys)

def multiset_add(sx:Multiset a, sy:Multiset a) -> Multiset a given (a|Ord) =
  UnsafeAsMultiset(nx, xs) = sx
  UnsafeAsMultiset(ny, ys) = sy
  combined = merge_sorted_tables xs ys
  AsList(_, unique_xs) = remove_duplicates_from_sorted_with_counts combined
  UnsafeAsMultiset(_, unique_xs)

instance Add(Multiset a) given (a|Ord)
  def (+)(sx, sy) = multiset_add sx sy
  zero = to_multiset []
