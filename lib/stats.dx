'# Stats
Probability distributions and other functions useful for statistical computing


'## Univariate probability distributions
Simulation and evaluation of [probability distributions](https://en.wikipedia.org/wiki/Probability_distribution). 

'## Dist interface
Distributions implement the `Dist` interface.

interface Dist d a
  log_pdf : d -> a -> Float     -- either the density function or mass function
  log_cdf : d -> a -> Float     -- the cumulative distribution function (CDF)
  log_sf : d -> a -> Float      -- the survivor function (complement of CDF)
  quantile : d -> Float -> a    -- the quantile function (inverse CDF)
  draw : d -> Key -> a          -- function for random draws


'### Bernoulli distribution
The [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution) is parameterised by its "success" probability, `p`.

data BernoulliDist = Bernoulli Float

instance Dist BernoulliDist Bool
  log_pdf = \(Bernoulli p) b.
    if (b)
     then log p
     else log1p (-p)
  log_cdf = \(Bernoulli p) b.
    if (b)
      then 0.0
      else log1p (-p)
  log_sf = \(Bernoulli p) b.
    if (b)
      then -infinity
      else log p
  quantile = \(Bernoulli p) q.
    q > (1 - p)
  draw = \(Bernoulli p) k.
    (rand k) < p


'### Binomial distribution
The [binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution) is parameterised by the number of trials, `n`, and the success probability, `p`. Mean is `np`.

data BinomialDist = Binomial Nat Float

def binomial_log_pdf_private (n: Nat) (p: Float) (x: Nat) : Float =
  nf = n_to_f n
  xf = n_to_f x
  if (xf > nf)
    then -infinity
    else (xf * (log p)) + ((nf - xf) * (log1p (-p))) +
      (lgamma (nf + 1)) - (lgamma (xf + 1)) - (lgamma (nf + 1 - xf))

instance Dist BinomialDist Nat
  log_pdf = \(Binomial n p) x.
    binomial_log_pdf_private n p x
  log_cdf = \(Binomial n p) x.
    xp1:Nat = x + 1
    logsumexp $ for i:(Fin xp1). binomial_log_pdf_private n p (ordinal i)
  log_sf = \(Binomial n p) x.
    nmx = n -| x
    logsumexp $ for i:(Fin nmx). binomial_log_pdf_private n p (x + 1 + ordinal i)
  quantile = \(Binomial n p) q.
    np1:Nat = n + 1
    lpdf = for i:(Fin np1). binomial_log_pdf_private n p (ordinal i)
    cdf = cdf_for_categorical lpdf
    mi = search_sorted cdf q
    ordinal $ from_just mi
  draw = \(Binomial n p) k.
    sum $ map b_to_n (rand_vec n (draw $ Bernoulli p) k)

-- TODO: remove "binom" from the prelude


'### Exponential distribution
The [exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution) is parameterised by its *rate*, `r > 0`, so that the mean of the distribution is `1/r`.

data ExponentialDist = Exponential Float

instance Dist ExponentialDist Float
  log_pdf = \(Exponential r) x.
    if (x < 0.0)
      then -infinity
      else (log r) - (r * x)
  log_cdf = \(Exponential r) x.
    if (x < 0.0)
      then -infinity
      else log1p (-exp (-r * x))
  log_sf = \(Exponential r) x.
    if (x < 0.0)
      then 0.0
      else -r * x
  quantile = \(Exponential r) q.
    (log1p (-q)) / -r
  draw = \(Exponential r) k.
    (log1p (-(rand k))) / -r


'### Gaussian distribution
The Gaussian, or [normal distribution](https://en.wikipedia.org/wiki/Normal_distribution) is parameterised by its *mean*, `mu`, and *standard deviation*, `sig`. ie. **not** variance or precision.

data GaussianDist = Gaussian Float Float

instance Dist GaussianDist Float
  log_pdf = \(Gaussian mu sig) x.
    -0.5 * ((log (2 * pi * (sq sig))) + (sq ((x - mu) / sig)))
  log_cdf = todo  -- need some sort of "erf" function for this
  log_sf = todo   -- ditto
  quantile = todo -- need inverse "erf" function
  draw = \(Gaussian mu sig) k.
    mu + (sig * (randn k))


'### Geometric distribution
This [geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution) is defined as the number of trials until a success (**not** the number of failures). Parameterised by success probability, `p`. Mean is `1/p`.

data GeometricDist = Geometric Float

instance Dist GeometricDist Nat
  log_pdf = \(Geometric p) n.
    nf = n_to_f n
    ((nf-1)*(log1p (-p))) + (log p)
  log_cdf = \(Geometric p) n.
    nf = n_to_f n
    log1p (-pow (1-p) nf)
  log_sf = \(Geometric p) n.
    (n_to_f n) * (log1p (-p))
  quantile = \(Geometric p) q.
    f_to_n $ ceil $ (log1p (-q)) / (log1p (-p))
  draw = \(Geometric p) k.
    f_to_n $ ceil $ (log1p (-(rand k))) / (log1p (-p))

'### Poisson distribution
The [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution) is parameterised by its rate, `r > 0`. Mean is `r`.

data PoissonDist = Poisson Float

def poisson_log_pdf_private (r: Float) (n: Nat) : Float =
  nf = n_to_f n
  (nf * (log r)) - r - lgamma(nf + 1)

instance Dist PoissonDist Nat
  log_pdf = \(Poisson r) x.
    poisson_log_pdf_private r x
  log_cdf = \(Poisson r) x.
    xp1:Nat = x + 1
    logsumexp $ for i:(Fin xp1). poisson_log_pdf_private r (ordinal i)
  log_sf = \(Poisson r) x.
    xp1:Nat = x + 1
    lcdf = logsumexp $ for i:(Fin xp1). poisson_log_pdf_private r (ordinal i)
    log1p (-exp lcdf)
  quantile = \(Poisson r) q.
    yield_state (0::Nat) \x.
      with_state 0.0 \cdf.
        while do
          cdf := (get cdf) + exp (poisson_log_pdf_private r (get x))
          if (get cdf) > q
            then
              False
            else
              x := (get x) + 1
              True
  draw = \(Poisson r) k.
    exp_neg_rate = exp (-r)
    [current_k, next_k] = split_key k
    yield_state 0 \ans.
      with_state (rand current_k) \p. with_state next_k \k'.
        while do
          if get p > exp_neg_rate
            then
              [ck, nk] = split_key (get k')
              p := (get p) * rand ck
              ans := (get ans) + 1
              k' := nk
              True
            else
              False

-- TODO: remove "poisson" from prelude
  

'### Uniform distribution
The [uniform distribution](https://en.wikipedia.org/wiki/Continuous_uniform_distribution) is continuous on an interval determined by a lower bound, `l`, and upper bound, `u > l`. Mean is `(l+u)/2`.

data UniformDist = Uniform Float Float

instance Dist UniformDist Float
  log_pdf = \(Uniform l u) x.
    if (x >= l)&&(x <= u)
      then -log (u - l)
      else -infinity
  log_cdf = \(Uniform l u) x.
    if (x < l)
      then -infinity
      else if (x > u)
        then 0.0
        else (log (x-l)) - (log (u-l))
  log_sf = \(Uniform l u) x.
    if (x < l)
      then 0.0
      else if (x > u)
        then -infinity
        else (log (u-x)) - (log (u-l))
  quantile = \(Uniform l u) q.
    l + ((u - l) * q)
  draw = \(Uniform l u) k.
    l + ((u - l) * (rand k))
  

'## Data summaries

def mean_and_var {n} (xs:n=>Float) : (Float & Float) =
  m = mean xs
  ss = sum for i. sq (xs.i - m)
  v = ss / ((n_to_f (size n)) - 1.0)
  (m, v)

def var {n} (xs:n=>Float) : Float =
  snd $ mean_and_var xs

def sd {n} (xs:n=>Float) : Float =
  sqrt $ var xs

def mean_and_cov {n d} (xs:n=>d=>Float) : (d=>Float & d=>d=>Float) =
   xsMean :    d=>Float = (for i. sum for j. xs.j.i) / n_to_f (size n)
   xsCov  : d=>d=>Float = (for i i'. sum for j.
                           (xs.j.i' - xsMean.i') *
                           (xs.j.i  - xsMean.i )   ) / (n_to_f (size n) - 1)
   (xsMean, xsCov)

def cov_mat {n d} (xs:n=>d=>Float) : d=>d=>Float =
  snd $ mean_and_cov xs

def cov {n} (x:n=>Float) (y:n=>Float) : Float =
  xm = mean x
  ym = mean y
  ss = sum for i. (x.i - xm) * (y.i - ym)
  ss / (n_to_f (size n) - 1)

def cor {n} (x:n=>Float) (y:n=>Float) : Float =
  (cov x y) / ((sd x) * (sd y))