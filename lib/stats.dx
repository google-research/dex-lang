'# Stats
Probability distributions and other functions useful for statistical computing


'## Univariate probability distributions
Simulation and evaluation of [probability distributions](https://en.wikipedia.org/wiki/Probability_distribution). 

'## Dist interface
Distributions implement the `Dist` interface.

interface Dist d a
  log_pdf : d -> a -> Float     -- either the density function or mass function
  log_cdf : d -> a -> Float     -- the cumulative distribution function (CDF)
  log_sf : d -> a -> Float      -- the survivor function (complement of CDF)
  quantile : d -> Float -> a    -- the quantile function (inverse CDF)
  draw : d -> Key -> a          -- function for random draws


'### Bernoulli distribution
The [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution) is parameterised by its "success" probability, `prob`.

data BernoulliDist = Bernoulli Float

instance Dist BernoulliDist Bool
  log_pdf = \(Bernoulli prob) b.
    if b
     then log prob
     else log1p (-prob)
  log_cdf = \(Bernoulli prob) b.
    if b
      then 0.0
      else log1p (-prob)
  log_sf = \(Bernoulli prob) b.
    if b
      then -infinity
      else log prob
  quantile = \(Bernoulli prob) q.
    q > (1 - prob)
  draw = \(Bernoulli prob) k.
    rand k < prob


'### Binomial distribution
The [binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution) is parameterised by the number of trials, `trials`, and the success probability, `prob`. Mean is `trials*prob`.

data BinomialDist = Binomial Nat Float

def binomial_log_pdf (trials: Nat) (prob: Float) (x: Nat) : Float =
  tf = n_to_f trials
  xf = n_to_f x
  if (xf > tf)
    then -infinity
    else (xf * log prob) + ((tf - xf) * log1p (-prob)) +
      lgamma (tf + 1) - lgamma (xf + 1) - lgamma (tf + 1 - xf)

instance Dist BinomialDist Nat
  log_pdf = \(Binomial trials prob) x.
    binomial_log_pdf trials prob x
  log_cdf = \(Binomial trials prob) x.
    xp1:Nat = x + 1
    logsumexp $ for i:(Fin xp1). binomial_log_pdf trials prob (ordinal i)
  log_sf = \(Binomial trials prob) x.
    tmx = trials -| x
    logsumexp $ for i:(Fin tmx). binomial_log_pdf trials prob (x + 1 + ordinal i)
  quantile = \(Binomial trials prob) q.
    tp1:Nat = trials + 1
    lpdf = for i:(Fin tp1). binomial_log_pdf trials prob (ordinal i)
    cdf = cdf_for_categorical lpdf
    mi = search_sorted cdf q
    ordinal $ from_just mi
  draw = \(Binomial trials prob) k.
    sum $ map b_to_n (rand_vec trials (draw $ Bernoulli prob) k)


'### Exponential distribution
The [exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution) is parameterised by its *rate*, `rate > 0`, so that the mean of the distribution is `1/rate`.

data ExponentialDist = Exponential Float

instance Dist ExponentialDist Float
  log_pdf = \(Exponential rate) x.
    if (x < 0.0)
      then -infinity
      else log rate - (rate * x)
  log_cdf = \(Exponential rate) x.
    if (x < 0.0)
      then -infinity
      else log1p (-exp (-rate * x))
  log_sf = \(Exponential rate) x.
    if (x < 0.0)
      then 0.0
      else -rate * x
  quantile = \(Exponential rate) q.
    log1p (-q) / -rate
  draw = \(Exponential rate) k.
    log1p (-rand k) / -rate


'### Geometric distribution
This [geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution) is defined as the number of trials until a success (**not** the number of failures). Parameterised by success probability, `prob`. Mean is `1/prob`.

data GeometricDist = Geometric Float

instance Dist GeometricDist Nat
  log_pdf = \(Geometric prob) n.
    if (prob == 1)
      then
        if (n == 1)
          then 0
          else -infinity
      else
        nf = n_to_f n
        ((nf-1)*log1p (-prob)) + log prob
  log_cdf = \(Geometric prob) n.
    nf = n_to_f n
    log1p (-pow (1-prob) nf)
  log_sf = \(Geometric prob) n.
    n_to_f n * log1p (-prob)
  quantile = \(Geometric prob) q.
    f_to_n $ ceil $ log1p (-q) / log1p (-prob)
  draw = \(Geometric prob) k.
    f_to_n $ ceil $ log1p (-rand k) / log1p (-prob)


'### Normal distribution
The Gaussian, or [normal distribution](https://en.wikipedia.org/wiki/Normal_distribution) is parameterised by its *mean*, `loc`, and *standard deviation*, `scale`. ie. **not** variance or precision.

data NormalDist = Normal Float Float

instance Dist NormalDist Float
  log_pdf = \(Normal loc scale) x.
    -0.5 * (log (2 * pi * (sq scale)) + (sq ((x - loc) / scale)))
  log_cdf = todo  -- need some sort of "erf" function for this
  log_sf = todo   -- ditto
  quantile = todo -- need inverse "erf" function
  draw = \(Normal loc scale) k.
    loc + (scale * randn k)


'### Poisson distribution
The [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution) is parameterised by its rate, `rate > 0`. Mean is `rate`.

data PoissonDist = Poisson Float

def poisson_log_pdf (rate: Float) (n: Nat) : Float =
  nf = n_to_f n
  (nf * log rate) - rate - lgamma (nf + 1)

instance Dist PoissonDist Nat
  log_pdf = \(Poisson rate) x.
    poisson_log_pdf rate x
  log_cdf = \(Poisson rate) x.
    xp1:Nat = x + 1
    logsumexp $ for i:(Fin xp1). poisson_log_pdf rate (ordinal i)
  log_sf = \(Poisson rate) x.
    xp1:Nat = x + 1
    lcdf = logsumexp $ for i:(Fin xp1). poisson_log_pdf rate (ordinal i)
    log1p (-exp lcdf)
  quantile = \(Poisson rate) q.
    yield_state (0::Nat) \x.
      with_state 0.0 \cdf.
        while do
          cdf := (get cdf) + exp (poisson_log_pdf rate (get x))
          if (get cdf) > q
            then
              False
            else
              x := (get x) + 1
              True
  draw = \(Poisson rate) k.
    exp_neg_rate = exp (-rate)
    [current_k, next_k] = split_key k
    yield_state 0 \ans.
      with_state (rand current_k) \p. with_state next_k \k'.
        while do
          if get p > exp_neg_rate
            then
              [ck, nk] = split_key (get k')
              p := (get p) * rand ck
              ans := (get ans) + 1
              k' := nk
              True
            else
              False
  

'### Uniform distribution
The [uniform distribution](https://en.wikipedia.org/wiki/Continuous_uniform_distribution) is continuous on an interval determined by a lower bound, `low`, and upper bound, `high > low`. Mean is `(low+high)/2`.

data UniformDist = Uniform Float Float

instance Dist UniformDist Float
  log_pdf = \(Uniform low high) x.
    if (x >= low)&&(x <= high)
      then -log (high - low)
      else -infinity
  log_cdf = \(Uniform low high) x.
    if (x < low)
      then -infinity
      else if (x > high)
        then 0.0
        else log (x - low) - log (high - low)
  log_sf = \(Uniform low high) x.
    if (x < low)
      then 0.0
      else if (x > high)
        then -infinity
        else log (high - x) - log (high - low)
  quantile = \(Uniform low high) q.
    low + ((high - low) * q)
  draw = \(Uniform low high) k.
    low + ((high - low) * rand k)
  

'## Data summaries
Some data summary functions. Note that `mean` is provided by the prelude.

'### Summaries for vector quantities

def mean_and_variance {n a} [VSpace a, Mul a] (xs:n=>a) : (a & a) =
  m = mean xs
  ss = sum for i. sq (xs.i - m)
  v = ss / (n_to_f (size n) - 1)
  (m, v)

def variance {n a} [VSpace a, Mul a] (xs:n=>a) : a =
  snd $ mean_and_variance xs

def std_dev {n a} [VSpace a, Mul a, Floating a] (xs:n=>a) : a =
  sqrt $ variance xs

def covariance {n a} [VSpace a, Mul a] (xs:n=>a) (ys:n=>a) : a =
  xm = mean xs
  ym = mean ys
  ss = sum for i. (xs.i - xm) * (ys.i - ym)
  ss / (n_to_f (size n) - 1)

def correlation {n a} [VSpace a, Mul a, Floating a, Fractional a]
    (xs:n=>a) (ys:n=>a) : a =
  divide (covariance xs ys) (std_dev xs * std_dev ys)

'### Summaries for matrix quantities

def mean_and_variance_matrix {n d a} [VSpace a, Mul a] (xs:n=>d=>a) : (d=>a & d=>d=>a) =
  xsMean:d=>a = (for i. sum for j. xs.j.i) / n_to_f (size n)
  xsCov:d=>d=>a = (for i i'. sum for j.
                         (xs.j.i' - xsMean.i') *
                           (xs.j.i  - xsMean.i ) ) / (n_to_f (size n) - 1)
  (xsMean, xsCov)

def variance_matrix {n d a} [VSpace a, Mul a] (xs:n=>d=>a) : d=>d=>a =
  snd $ mean_and_variance_matrix xs

def correlation_matrix {n d a} [VSpace a, Mul a, Floating a, Fractional a]
    (xs:n=>d=>a) : d=>d=>a =
  cvm = variance_matrix xs
  for i. for j. divide cvm.i.j (sqrt cvm.i.i * sqrt cvm.j.j)


-- eof
