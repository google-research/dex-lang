import set
import sort

'# Example tables

def students : (Fin 3)=>{name: String & age: Int & favColor: String} =
  [ {name="Bob"  , age=12, favColor="blue" }
  , {name="Alice", age=17, favColor="green"}
  , {name="Eve"  , age=13, favColor="red"  }
  ]

def studentsMissing : (Fin 3)=>{name: String & age:(Maybe Int) & favColor:(Maybe String)} =
  [ {name="Bob"  , age=Nothing, favColor=Just "blue" }
  , {name="Alice", age=Just 17, favColor=Just "green"}
  , {name="Eve"  , age=Just 13, favColor=Nothing     }
  ]

def employees : (Fin 6)=>{lastname: String & deptID: Maybe Int} =
  [ {lastname="Rafferty"  , deptID=Just 31}
  , {lastname="Jones"     , deptID=Just 32}
  , {lastname="Heisenberg", deptID=Just 33}
  , {lastname="Robinson"  , deptID=Just 34}
  , {lastname="Smith"     , deptID=Just 34}
  , {lastname="Williams"  , deptID=Nothing}    
  ]

def departments : (Fin 4)=>{deptname: String & deptID: Int} =
  [ {deptname="Sales"      , deptID=31}
  , {deptname="Engineering", deptID=33}
  , {deptname="Clerical"   , deptID=34}
  , {deptname="Marketing"  , deptID=35}   
  ]

def jellyAnon : (Fin 10)=>{get_acne:Bool & red:Bool & black:Bool & white:Bool & green:Bool & yellow:Bool & brown:Bool & orange:Bool & pink:Bool & purple:Bool} =
  [ {get_acne=True, red=False, black=False, white=False, green=True , yellow=False, brown=False, orange=True , pink=False, purple=False}
  , {get_acne=True,  red=False, black=True,  white=False, green=True , yellow=True , brown=False, orange=False, pink=False, purple=False}
  , {get_acne=False, red=False, black=False, white=False, green=True , yellow=False, brown=False, orange=False, pink=True , purple=False}
  , {get_acne=False, red=False, black=False, white=False, green=False, yellow=True , brown=False, orange=False, pink=False, purple=False}
  , {get_acne=False, red=False, black=False, white=False, green=False, yellow=True , brown=False, orange=False, pink=True , purple=False}
  , {get_acne=True,  red=False, black=True,  white=False, green=False, yellow=False, brown=False, orange=True , pink=True , purple=False}
  , {get_acne=False, red=False, black=True,  white=False, green=False, yellow=False, brown=False, orange=False, pink=True , purple=False}
  , {get_acne=True,  red=False, black=False, white=False, green=False, yellow=False, brown=True , orange=True , pink=False, purple=False}
  , {get_acne=True,  red=False, black=False, white=False, green=False, yellow=False, brown=False, orange=True , pink=False, purple=False}
  , {get_acne=False, red=True , black=False, white=False, green=False, yellow=True , brown=True , orange=False, pink=True , purple=False}
  ]

def jellyNamed : (Fin 10)=>{name:String & get_acne:Bool & red:Bool & black:Bool & white:Bool & green:Bool & yellow:Bool & brown:Bool & orange:Bool & pink:Bool & purple:Bool} =
  [ {name="Emily",    get_acne=True, red=False, black=False, white=False, green=True , yellow=False, brown=False, orange=True , pink=False, purple=False}
  , {name="Jacob",    get_acne=True,  red=False, black=True,  white=False, green=True , yellow=True , brown=False, orange=False, pink=False, purple=False}
  , {name="Emma",     get_acne=False, red=False, black=False, white=False, green=True , yellow=False, brown=False, orange=False, pink=True , purple=False}
  , {name="Aidan",    get_acne=False, red=False, black=False, white=False, green=False, yellow=True , brown=False, orange=False, pink=False, purple=False}
  , {name="Madison",  get_acne=False, red=False, black=False, white=False, green=False, yellow=True , brown=False, orange=False, pink=True , purple=False}
  , {name="Ethan",    get_acne=True,  red=False, black=True,  white=False, green=False, yellow=False, brown=False, orange=True , pink=True , purple=False}
  , {name="Hannah",   get_acne=False, red=False, black=True,  white=False, green=False, yellow=False, brown=False, orange=False, pink=True , purple=False}
  , {name="Matthew",  get_acne=True,  red=False, black=False, white=False, green=False, yellow=False, brown=True , orange=True , pink=False, purple=False}
  , {name="Hailey",   get_acne=True,  red=False, black=False, white=False, green=False, yellow=False, brown=False, orange=True , pink=False, purple=False}
  , {name="Nicholas", get_acne=False, red=True , black=False, white=False, green=False, yellow=True , brown=True , orange=False, pink=True , purple=False}
  ]

def gradebook : (Fin 3)=>{name:String & age:Int & quiz1:Int & quiz2:Int & midterm:Int & quiz3:Int & quiz4:Int & final:Int} =
  [ {name="Bob"  , age=12, quiz1=8, quiz2=9, midterm=77, quiz3=7, quiz4=9, final=87}
  , {name="Alice", age=17, quiz1=6, quiz2=8, midterm=88, quiz3=8, quiz4=7, final=85}
  , {name="Eve"  , age=13, quiz1=7, quiz2=9, midterm=84, quiz3=8, quiz4=8, final=77}
  ]

def gradebookMissing : (Fin 3)=>{name:String & age:Maybe Int & quiz1:Maybe Int & quiz2:Maybe Int & midterm:Maybe Int & quiz3:Maybe Int & quiz4:Maybe Int & final:Maybe Int} =
  [ {name="Bob"  , age=Just 12, quiz1=Just 8,  quiz2=Just 9, midterm=Just 77, quiz3=Just 7,  quiz4=Just 9, final=Just 87}
  , {name="Alice", age=Just 17, quiz1=Just 6,  quiz2=Just 8, midterm=Just 88, quiz3=Nothing, quiz4=Just 7, final=Just 85}
  , {name="Eve"  , age=Just 13, quiz1=Nothing, quiz2=Just 9, midterm=Just 84, quiz3=Just 8,  quiz4=Just 8, final=Just 77}
  ]

def gradebookSeq : (Fin 3)=>{name:String & age:Int & quizzes:(Fin 4=>Int) & midterm:Int & final:Int} =
  [ {name="Bob"  , age=12, quizzes=[8, 9, 7, 9], midterm=77, final=87}
  , {name="Alice", age=17, quizzes=[6, 8, 8, 7], midterm=88, final=85}
  , {name="Eve"  , age=13, quizzes=[7, 9, 8, 8], midterm=84, final=77}
  ]

def gradebookTable : (Fin 3)=>{name:String & age:Int & quizzes:(Fin 4=>{quiznum:Int & grade:Int}) & midterm:Int & final:Int} =
  [ {name="Bob"  , age=12, quizzes=[ {quiznum=1, grade=8}
                                   , {quiznum=2, grade=9}
                                   , {quiznum=3, grade=7}
                                   , {quiznum=4, grade=9}], midterm=77, final=87}
  , {name="Alice", age=17, quizzes=[ {quiznum=1, grade=6}
                                   , {quiznum=2, grade=8}
                                   , {quiznum=3, grade=8}
                                   , {quiznum=4, grade=7}], midterm=88, final=85}
  , {name="Eve"  , age=13, quizzes=[ {quiznum=1, grade=7}
                                   , {quiznum=2, grade=9}
                                   , {quiznum=3, grade=8}
                                   , {quiznum=4, grade=8}], midterm=84, final=77}
  ]


'# Experiment: Indexing by sets

def getColumn {n f a} (c:Label) (t:n=>{@c:a & ...f}) : n=>a =
  for i.
    {@c=val, ...r} = t.i
    val

student_names = getColumn ##name students
studentIx = StringSetIx $ toSet student_names

students_ix_by_names = for i:studentIx.
  {name=_, ...r} = students.((ordinal i)@_)
  r

-- Note:  It'd be nice to wrap this logic in a helper function like this:
-- def reindex_table_by_column {n f a} (c:Label) (t:n=>{@c:String & ...f}) :
--   (StringSetIx set)=>{&...f} =
--     ix_vals = getColumn c t
--     newIx : Type = StringSetIx $ toSet ix_vals
--     for i:newIx.
--       {@c=_, ...r} = t.((ordinal i)@_)
--       r
-- But that would require delayed resolution of "set".


'# Table API

'## Constructors

Void = Fin 0
def emptyTable : Void=>{&} = for i. error "This should be an empty table!"

def addRows {n m a} (t:n=>a) (t':m=>a) : (n|m)=>a =
  for i. case i of
    Left ni  -> t.ni
    Right mi -> t'.mi

:p addRows students [{name="Colton", age=19, favColor="blue"}]

:p addRows gradebook []


-- ### `addColumn :: t1:Table * c:ColName * vs:Seq<Value> -> t2:Table`
def addColumn {n f a} (t:n=>{&...f}) (c:Label) (vs:n=>a) : n=>{@c:a & ...f} =
  for i. {@c=vs.i, ...t.i}

hairColor = ["brown", "red", "blonde"]
:p addColumn students ##haircolor hairColor

presentation = [9, 9, 6]
addColumn gradebook ##presentation presentation


-- ### `buildColumn :: t1:Table * c:ColName * f:(r:Row -> v:Value) -> t2:Table`
def buildColumn {n f a} (t:n=>{&...f}) (c:Label) (fn: {&...f} -> a) : n=>{@c:a & ...f} =
  for i. {@c=fn t.i, ...t.i}

:p buildColumn students ##is_teenager \{age, ..._}.
  (12 < age ) && (age < 20)  -- Very terse syntax!

:p buildColumn gradebook ##did_well_in_final \{final, ..._}.
  85 <= final


-- ### `vcat :: t1:Table * t2:Table -> t3:Table`
def vcat {n m a} (t:n=>a) (t':m=>a) : (n|m)=>a = addRows t t'

increasedAge = for i.
  {age, ...other} = students.i
  {age=age + 1, ...other}
:p vcat students increasedAge


curve = \grade. grade + 5
curvedMidtermAndFinal = for i.
  {midterm, final, ...other} = gradebook.i
  {midterm=curve(midterm), final=curve(final), ...other}
:p vcat gradebook curvedMidtermAndFinal


-- moved up from below
-- ### `dropColumns :: t1:Table * cs:Seq<ColName> -> t2:Table`
def dropColumns {n f'} (f: Fields) (t:n=>{...f & ...f'}) : n=>{&...f'} =
  for i.
    {@...f=_, ...r} = t.i
    r

:p dropColumns {age: _ ? } students
:p dropColumns {final: _ ? midterm: _} gradebook



def hcat {n f f'} (t:n=>{&...f}) (t':n=>{&...f'}) : n=>{...f & ...f'} =
  for i. {...(t.i), ...(t'.i)}

:p hcat students $ dropColumns {name: _ ? age: _} gradebook
:p hcat (dropColumns {name: _ ? age: _} students) gradebook


def values {n a} : n=>a -> n=>a = id

:p values [{name="Alice"}, {name="Bob"}]
:p values [{name="Alice", age=12},
           {name="Bob", age=13}]


-- ### `crossJoin :: t1:Table * t2:Table -> t3:Table`
def crossJoin {n m f f'} (t:n=>{&...f}) (t':m=>{&...f'}) : (n & m)=>{...f & ...f'} =
  for (i, j). {...(t.i), ...(t'.j)}

-- Subtable is used in this example, but its definition appears to be missing.
def subTable {n m a f'} (rows:m=>n) (f: Fields) (t: n=>{...f & ...f'}) : m=>{&...f} =
  for i:m.
    {@...f=v, ...} = t.(rows.i)
    v

-- > petiteJelly = subTable(jellyAnon, [0, 1], [0, 1, 2])
-- > petiteJelly
-- | get acne | red   | black |
-- | -------- | ----- | ----- |
-- | =True     | =False | =False |
-- | =True     | =False | =True  |


-- :p crossJoin students petiteJelly

-- > crossJoin(students, petiteJelly)
-- | name    | age | favorite color | get acne | red   | black |
-- | ------- | --- | -------------- | -------- | ----- | ----- |
-- | "Bob"   | 12  | "blue"         | =True     | =False | =False |
-- | "Bob"   | 12  | "blue"         | =True     | =False | =True  |
-- | "Alice" | 17  | "green"        | =True     | =False | =False |
-- | "Alice" | 17  | "green"        | =True     | =False | =True  |
-- | "Eve"   | 13  | "red"          | =True     | =False | =False |
-- | "Eve"   | 13  | "red"          | =True     | =False | =True  |
-- > crossJoin(emptyTable, petiteJelly)
-- | get acne | red   | black |
-- | -------- | ----- | ----- |

'### TODO: `leftJoin` (lists of labels)

-- It should be sufficient to do the join on a single column. One can always
-- restructure the table so that the join happens on a tuple of values from
-- the flattened columns.

def findInUnordered {a n} [Eq a] (xs:n=>a) (v:a) : Maybe n =
  -- Wasteful, but at least the parallelism is exposed.
  (AsList num_found found_table) = argFilter (\x. x == v) xs
  case num_found == 0 of
    True -> Nothing
    False -> Just found_table.(unsafeFromOrdinal _ 0)

-- The implementation below takes (n * m) time, but could be done in O(n log m)
-- if table r was indexed by a set of values of type a

def leftJoin {n m a f f'} [Eq a]
  (c:Label)
  (left: n=>{@c: a & ...f})
  (right:m=>{@c: a & ...f'})
  : n=>{@c: a & extra: Maybe { &...f'} & ...f} =
    right_c_vals = getColumn c right
    for i:n.
      {@c=left_c_val, ...rest_left} = left.i
      newdata = case findInUnordered right_c_vals left_c_val of
        Nothing -> Nothing
        Just j ->
          {@c=_, ...rest_right} = right.j
          Just rest_right
      {@c=left_c_val, extra=newdata, ...rest_left}

:p leftJoin ##name students gradebook

-- TODO: Match the example below exactly once multiple fields are supported.
--:p leftJoin students gradebook {name:_ ? age:_}


-- > leftJoin(students, gradebook, ["name", "age"])
-- | name    | age | favorite color | quiz1 | quiz2 | midterm | quiz3 | quiz4 | final |
-- | ------- | --- | -------------- | ----- | ----- | ------- | ----- | ----- | ----- |
-- | "Bob"   | 12  | "blue"         | 8     | 9     | 77      | 7     | 9     | 87    |
-- | "Alice" | 17  | "green"        | 6     | 8     | 88      | 8     | 7     | 85    |
-- | "Eve"   | 13  | "red"          | 7     | 9     | 84      | 8     | 8     | 77    |

-- The original example is ill-formed, because employees has deptID as Maybe Int,
-- while departments has deptID as Int.  So we need to fix the tables up a bit.
departments_maybe_deptID = for i.
  {deptID=d, ...rest} = departments.i
  {deptID=Just d, ...rest}

-- Todo: move to prelude
instance {a} [Eq a] Eq (Maybe a)
  (==) = \maybe_x maybe_y. case maybe_x of
    Nothing -> case maybe_y of
      Nothing -> True
      Just y -> False
    Just x -> case maybe_y of
      Just y -> x == y
      Nothing -> False

:p leftJoin ##deptID employees departments_maybe_deptID
-- > leftJoin(employees, departments, ["Department ID"])
-- | Last Name    | Department ID | Department Name |
-- | ------------ | ------------- | --------------- |
-- | "Rafferty"   | 31            | "Sales"         |
-- | "Jones"      | 32            |                 |
-- | "Heisenberg" | 33            | "Engineering"   |
-- | "Robinson"   | 34            | "Clerical"      |
-- | "Smith"      | 34            | "Clerical"      |
-- | "Williams"   |               |                 |

'## Properties

def nrows {n a} (t:n=>a) : Int = size n

nrows emptyTable
nrows studentsMissing

'### TODO: `ncols` (type-classes over records)

-- TODO: Is this even expressible? Perhaps through type classes?
-- If we can do Eq of records in user space then we can count fields too.
def ncols {n f} (t:n=>{&...f}) : Int = todo

ncols students
ncols studentsMissing

'### TODO: `header` (type-classes over records)

-- TODO: Is this even expressible? Perhaps through type classes again.
def header {n f} (t:n=>{...f}) : List Label = todo
-- > header(students)
-- ["name", "age", "favorite color"]
-- > header(gradebook)
-- ["name", "age", "quiz1", "quiz2", "midterm", "quiz3", "quiz4", "final"]

'## Access Subcomponents

def getRow {n a} (t:n=>a) (i:n) : a = t.i

getRow students (0@_)
getRow gradebook (1@_)

def getValue {f a} (c:Label) (r:{@c:a & ...f}) : a =
  {@c=v, ...} = r
  v
-- > getValue([row: ("name", "Bob"),  ("age", 12)], "name")
-- "Bob"
-- > getValue([row: ("name", "Bob"),  ("age", 12)], "age")
-- 12

-- INEXPRESSIBLE: Columns are unordered
-- ### (overloading 1/2) `getColumn :: t:Table * n:Number -> vs:Seq<Value>`

-- ### (overloading 2/2) `getColumn :: t:Table * c:ColName -> vs:Seq<Value>`

-- Define above.
-- def getColumn {f n a} (c:Label) (t:n=>{@c:a & ...f}) : n=>a = todo

:p getColumn ##age students
-- > getColumn(students, "age")
-- [12, 17, 13]

:p getColumn ##name gradebook
-- > getColumn(gradebook, "name")
-- ["Bob", "Alice", "Eve"]

'## Subtable

def selectRows {n m a} (t:n=>a) (is:m=>n) : m=>a = for i:m. t.(is.i)

:p selectRows students [2@_, 0@_, 2@_, 1@_]
:p selectRows gradebook [2@_, 1@_]


def selectRowsMask {n a} (t:n=>a) (shouldTake:n=>Bool) : List a =
  concat $ for i.
    case shouldTake.i of
      True  -> AsList _ [t.i]
      False -> mempty

:p selectRowsMask students [True, False, True]
:p selectRowsMask gradebook [False, False, True]


-- INEXPRESSIBLE: Columns are unordered
-- ### (overload 1/3) `selectColumns :: t1:Table * bs:Seq<Boolean> -> t2:Table`

-- INEXPRESSIBLE: Columns are unordered
-- ### (overload 2/3) `selectColumns :: t1:Table * ns:Seq<Number> -> t2:Table`

-- ### (overload 3/3) `selectColumns :: t1:Table * cs:Seq<ColName> -> t2:Table`
def selectColumns {n f'} (f: Fields) (t: n=>{...f & ...f'}) : n=>{&...f} =
  for i.
    {@...f=v, ...} = t.i
    v
 
:p selectColumns {favColor:_ ? age:_} students
:p selectColumns {final:_ ? name:_ ? midterm:_} gradebook


def head' {n a} (xs:n=>a) (num:Int) : Maybe ((Fin num)=>a) =
  -- TODO: allow negative arguments to `head'`
  s = size n
  case s < num of
    True -> Nothing
    False -> Just for i:(Fin num). xs.(unsafeFromOrdinal n (ordinal i))

:p head' students 1

-- TODO: allow negative arguments to `head'`
-- :p head' students -2
-- | name    | age | favorite color |
-- | ------- | --- | -------------- |
-- | "Bob"   | 12  | "blue"         |


'### TODO: `distinct` (type-classes for records)

-- TODO: Will work once we can make typeclass interfaces for arbitrary records.
-- Here we need to construct an Ord instance to do this efficiently, and Eq to
-- to it at all.
def distinct {n a} [Ord a] (t:n=>a) : List a =
  (UnsafeAsSet _ uniquetable) = toSet t
  AsList _ uniquetable

:p distinct students

-- > distinct(students)
-- | name    | age | favorite color |
-- | ------- | --- | -------------- |
-- | "Bob"   | 12  | "blue"         |
-- | "Alice" | 17  | "green"        |
-- | "Eve"   | 13  | "red"          |
-- > distinct(selectColumns(gradebook, ["quiz3"]))
-- | quiz3 |
-- | ----- |
-- | 7     |
-- | 8     |

def dropColumn {n f a} (c:Label) (t:n=>{@c:a & ...f}) : n=>{&...f} =
  for i.
    {@c=_, ...r} = t.i
    r

:p dropColumn ##age students
:p dropColumn ##final gradebook


-- dropColumns used to go here, but it was needed above for the `hcat` demo.


def tfilter {n a} (t:n=>a) (keep:a -> Bool) : List a =
  selectRowsMask t $ for i. keep t.i

:p tfilter students \{age, ..._}.
  age < 15

-- > ageUnderFifteen =
--     function(r):
--       getValue(r, "age") < 15
--     end
-- > tfilter(students, ageUnderFifteen)
-- | name  | age | favorite color |
-- | ----- | --- | -------------- |
-- | "Bob" | 12  | "blue"         |
-- | "Eve" | 13  | "red"          |

:p tfilter students \{name, ..._}.
  (listLength name) > 3

-- > nameLongerThan3Letters =
--     function(r):
--       length(getValue(r, "name")) > 3
--     end
-- > tfilter(gradebook, nameLongerThan3Letters)
-- | name    | age | quiz1 | quiz2 | midterm | quiz3 | quiz4 | final |
-- | ------- | --- | ----- | ----- | ------- | ----- | ----- | ----- |
-- | "Alice" | 17  | 6     | 8     | 88      | 8     | 7     | 85    |


'## Ordering

-- ### `tsort :: t1:Table * c:ColName * b:Boolean -> t2:Table`
-- TODO Boolean argument
def tsort {n f a} [Eq n, Ord a] (c:Label) (t:n=>{@c: a & ...f}) : n=>{@c: a & ...f} =
  ixs = argsort $ getColumn c t
  for i. t.(ixs.i)

:p tsort ##age students
-- > tsort(students, "age", true)
-- | name    | age | favorite color |
-- | ------- | --- | -------------- |
-- | "Bob"   | 12  | "blue"         |
-- | "Eve"   | 13  | "red"          |
-- | "Alice" | 17  | "green"        |

:p tsort ##final gradebook
-- > tsort(gradebook, "final", false)
-- | name    | age | quiz1 | quiz2 | midterm | quiz3 | quiz4 | final |
-- | ------- | --- | ----- | ----- | ------- | ----- | ----- | ----- |
-- | "Bob"   | 12  | 8     | 9     | 77      | 7     | 9     | 87    |
-- | "Alice" | 17  | 6     | 8     | 88      | 8     | 7     | 85    |
-- | "Eve"   | 13  | 7     | 9     | 84      | 8     | 8     | 77    |

'### TODO: `sortByColumns` (lists of labels)

-- ### `sortByColumns :: t1:Table * cs:Seq<ColName> -> t2:Table`
def sortByColumns {n f f' a} [Eq n, Ord a] (f: Fields) (t:n=>{...f & ...f'}) : n=>{...f & ...f'} =
  todo
-- > sortByColumns(students, ["age"])
-- | name    | age | favorite color |
-- | ------- | --- | -------------- |
-- | "Bob"   | 12  | "blue"         |
-- | "Eve"   | 13  | "red"          |
-- | "Alice" | 17  | "green"        |
-- > sortByColumns(gradebook, ["quiz2", "quiz1"])
-- | name    | age | quiz1 | quiz2 | midterm | quiz3 | quiz4 | final |
-- | ------- | --- | ----- | ----- | ------- | ----- | ----- | ----- |
-- | "Alice" | 17  | 6     | 8     | 88      | 8     | 7     | 85    |
-- | "Eve"   | 13  | 7     | 9     | 84      | 8     | 8     | 77    |
-- | "Bob"   | 12  | 8     | 9     | 77      | 7     | 9     | 87    |


-- ### `orderBy :: t1:Table * Seq<Exists K . getKey:(r:Row -> k:K) * compare:(k1:K * k2:K -> Boolean)> -> t2:Table`
def orderBy = todo
-- > nameLength =
--     function(r):
--       length(getValue(r, "name"))
--     end
-- > le =
--     function(n1, n2):
--       n1 <= n2
--     end
-- > orderBy(students, [(nameLength, le)])
-- | name    | age | favorite color |
-- | ------- | --- | -------------- |
-- | "Bob"   | 12  | "blue"         |
-- | "Eve"   | 13  | "red"          |
-- | "Alice" | 17  | "green"        |
-- > midtermAndFinal =
--     function(r):
--       [getValue(r, "midterm"), getValue(r, "final")]
--     end
-- > compareGrade =
--     function(g1, g2):
--       le(average(g1), average(g2))
--     end
-- > orderBy(gradebook, [(nameLength, ge), (midtermAndFinal, compareGrade)])
-- | name    | age | quiz1 | quiz2 | midterm | quiz3 | quiz4 | final |
-- | ------- | --- | ----- | ----- | ------- | ----- | ----- | ----- |
-- | "Alice" | 17  | 6     | 8     | 88      | 8     | 7     | 85    |
-- | "Eve"   | 13  | 7     | 9     | 84      | 8     | 8     | 77    |
-- | "Bob"   | 12  | 8     | 9     | 77      | 7     | 9     | 87    |


'## Aggregate

'### `count` (groupBy)
Takes a `Table` and a `ColName` representing the name of a column in that `Table`.
Produces a `Table` that summarizes how many rows have each value in the given column.

'#### Some setup to get efficient counting of duplicates.
This is mostly copied + modified from `set.dx`, could potentially be unified.

def unsafeAllExceptFirst {n a} (xs:n=>a) : List a =
  shortSize = Fin (max 0 ((size n) - 1))
  allButFirst = for i:shortSize. xs.(unsafeFromOrdinal _ ((ordinal i) + 1))
  (AsList _ allButFirst)

def mergeUniqueSortedListsWithCounts {a} [Eq a] (xlist:List (a & Int))
                                                (ylist:List (a & Int)) : List (a & Int) =
    -- This function is associative, for use in a monoidal reduction.
    -- Assumes all xs are <= all ys.
    -- The element at the end of xs might equal the
    -- element at the beginning of ys.  If so, this
    -- function removes the duplicate when concatenating the lists.
    (AsList nx xs) = xlist
    (AsList _  ys) = ylist
    case last xs of
      Nothing -> ylist
      Just (last_x, x_count) -> case first ys of
        Nothing -> xlist
        Just (first_y, y_count) -> case last_x == first_y of
          False -> concat [xlist,            ylist]
          True ->
            concat [allExceptLast xs,
                    (AsList 1 [(last_x, x_count + y_count)]),
                    unsafeAllExceptFirst ys]

def removeDuplicatesFromSortedWithCounts {n a} [Eq a] (xs:n=>a) : List (a & Int) =
  xlists = for i:n. (AsList 1 ([(xs.i, 1)]))
  reduce (AsList 0 []) mergeUniqueSortedListsWithCounts xlists

def count {n a f} [Ord a] (c:Label) (t:n=>{@c:a & ...f}) : List {value:a & count:Int} =
  c_vals = getColumn c t
  sorted_c_vals = sort c_vals
  (AsList _ distinct_vals) = removeDuplicatesFromSortedWithCounts sorted_c_vals
  AsList _ for i.
    (value, count) = distinct_vals.i
    {value, count}

:p count ##favColor students
-- > count(students, "favorite color")
-- | value   | count |
-- | ------- | ----- |
-- | "blue"  | 1     |
-- | "green" | 1     |
-- | "red"   | 1     |

:p count ##age gradebook
-- > count(gradebook, "age")
-- | value | count |
-- | ----- | ----- |
-- | 12    | 1     |
-- | 17    | 1     |
-- | 13    | 1     |


'### `bin` (groupBy)

-- ### `bin :: t1:Table * c:ColName * n:Number -> t2:Table`
-- Groups the values of a numeric column into bins.
-- The parameter `n` specifies the bin width.
-- This function is useful in creating histograms and converting continuous
-- random variables to categorical ones.

def bin {m f} (c:Label) (t:m=>{@c:Int & ...f}) (n:Int)
                        : List {lower:Int & upper:Int & count:Int} =
  -- Can only handle positive integers.
  c_vals = getColumn c t
  binned = for i. rem c_vals.i n
  (AsList _ distinct_vals) = removeDuplicatesFromSortedWithCounts binned
  AsList _ for i.
    (value, count) = distinct_vals.i
    {lower=value * n, upper=(value + 1) * n - 1, count}

:p bin ##age students 5

-- > bin(students, "age", 5)
-- | group            | count |
-- | ---------------- | ----- |
-- | "10 <= age < 15" | 2     |
-- | "15 <= age < 20" | 1     |

:p bin ##final gradebook 5

-- > bin(gradebook, "final", 5)
-- | group            | count |
-- | ---------------- | ----- |
-- | "75 <= age < 80" | 1     |
-- | "80 <= age < 85" | 0     |
-- | "85 <= age < 90" | 2     |


'### TODO: `pivotTable` (groupBy)
Partitions rows into groups and summarize each group with the functions in `agg`.
Each element of `agg` specifies the output column, the input column,
and the function that compute the summarizing value (e.g. average, sum, and count).

-- Inexpressible? Seems lke we can't match description exactly without allowing
-- some sort of type-level "unzip" for the output fields.
-- ### `pivotTable :: t1:Table * cs:Seq<ColName> * aggs:Seq<ColName * ColName * Function> -> t2:Table`
def pivotTable {n a f f'} (c:Label) (t:n=>{@c:a & ...f})
  (agg: List ({&...f} -> {&...f'})) :  n=>{@c:a & ...f'} =
    todo

-- ```lua
-- > pivotTable(students, ["favorite color"], [("age-average", "age", average)])
-- | favorite color | age-average |
-- | -------------- | ----------- |
-- | "blue"         | 12          |
-- | "green"        | 17          |
-- | "red"          | 13          |
-- > proportion =
--     function(bs):
--       n = length(filter(bs, function(b): b end))
--       n / length(bs)
--     end
-- > pivotTable(
--     jellyNamed,
--     ["get acne", "brown"],
--     [
--       ("red proportion", "red", proportion),
--       ("pink proportion", "pink", proportion)
--     ])
-- | get acne | brown | red proportion | pink proportion |
-- | -------- | ----- | -------------- | --------------- |
-- | false    | false | 0              | 3/4             |
-- | false    | true  | 1              | 1               |
-- | true     | false | 0              | 1/4             |
-- | true     | true  | 0              | 0               |


'### `groupBy` (groupBy)
Groups the rows of a table according to a specified key selector function and
creates a result value from each group and its key.
The rows of each group are projected by using a specified function.

def mergeUniqueSortedListsWithAux {a b} [Eq a]
  (xlist:List (a & List b))
  (ylist:List (a & List b)) : List (a & List b) =
    -- This function is associative, for use in a monoidal reduction.
    -- Assumes all xs are <= all ys.
    -- The element at the end of xs might equal the
    -- element at the beginning of ys.  If so, this
    -- function removes the duplicate when concatenating the lists,
    -- and appends the two lists of bs.
    (AsList nx xs) = xlist
    (AsList _  ys) = ylist
    case last xs of
      Nothing -> ylist
      Just (last_x, x_b_list) -> case first ys of
        Nothing -> xlist
        Just (first_y, y_b_list) -> case last_x == first_y of
          False -> concat [xlist,            ylist]
          True ->
            concat [allExceptLast xs,
                    (AsList 1 [(last_x, concat [x_b_list, y_b_list])]),
                    unsafeAllExceptFirst ys]

def removeDuplicatesFromSortedWithAux {n a b} [Eq a] (xs:n=>(a & b)) : List (a & List b) =
  xlists = for i:n.
    (xa, xb) = xs.i
    (AsList 1 [(xa, AsList 1 [xb])])
  reduce (AsList 0 []) mergeUniqueSortedListsWithAux xlists



-- TODO: Write this out to flatten out key and row' as records in the output
def groupBy {n row row' key value} [Eq key, Eq n, Ord key]
            (t:n=>row)
            (getKey:row -> key)
            (project:row -> value)
            (aggregate:key -> List value -> row')
            : List (key & row') =
  keys = for i. getKey t.i
  sortedixs = argsort keys
  sortedkeyvals = for i.
    (keys.(sortedixs.i), project t.(sortedixs.i))
  (AsList _ distinct_keys) = removeDuplicatesFromSortedWithAux sortedkeyvals
  AsList _ for j.
    (curkey, val_list) = distinct_keys.j
    (curkey, aggregate curkey val_list)


def colorTemp {f} ({favColor, ...}:{favColor:String & ...f}) : String =
  case favColor == "red" of
    True  -> "warm"
    False -> "cool"

def nameLength {f} ({name, ...}:{name:String & ...f}) : Int = listLength name
def aggregate {a} (key:a) ((AsList _ vs):List Int) : ({key:a & average:Float}) =
  {key, average=mean (map IToF vs)}

-- This has two columns for "key", not sure what was meant by original semantics.
:p groupBy students colorTemp nameLength aggregate

-- > colorTemp =
--     function(r):
--       if getValue(r, "favorite color") == "red":
--         "warm"
--       else:
--         "cool"
--       end
--     end
-- > nameLength =
--     function(r):
--       length(getValue(r, "name"))
--     end
-- > aggregate =
--     function(k, vs):
--       [row: ("key", k), ("average", average(vs))]
--     end
-- > groupBy(students, colorTemp, nameLength, aggregate)
-- | key    | average |
-- | ------ | ------- |
-- | "warm" | 3       |
-- | "cool" | 4       |

def abstractAge {f} ({age, ...}:{age:Int & ...f}) : String =
  case age <= 12 of
    True  -> "kid"
    False -> case age <= 19 of
      True  -> "teenager"
      False -> "adult"

:p groupBy gradebook abstractAge (\{final, ...}. final) aggregate

-- > abstractAge =
--     function(r):
--       if (getValue(r, "age") <= 12):
--         "kid"
--       else if (getValue(r, "age") <= 19):
--         "teenager"
--       else:
--         "adult"
--       end
--     end
-- > finalGrade =
--     function(r):
--       getValue(r, "final")
--     end
-- > groupBy(gradebook, abstractAge, finalGrade, aggregate)
-- | key        | average |
-- | ---------- | ------- |
-- | "kid"      | 87      |
-- | "teenager" | 81      |


'## Missing values

'### TODO: `completeCases` (type-classes over records)

-- Return a `Seq<Boolean>` with `true` entries indicating rows without missing values (complete cases) in table `t`.
--
-- > completeCases(students, "age")
-- [true, true, true]
-- > completeCases(studentsMissing, "age")
-- [false, true, true]

'### TODO: `dropna` (type-classes over records)

-- ### `dropna :: t1:Table -> t2:Table`
-- Removes rows that have some values missing
--
-- > dropna(studentsMissing)
-- | name    | age | favorite color |
-- | ------- | --- | -------------- |
-- | "Alice" | 17  | "green"        |
-- > dropna(gradebookMissing)
-- | name  | age | quiz1 | quiz2 | midterm | quiz3 | quiz4 | final |
-- | ----- | --- | ----- | ----- | ------- | ----- | ----- | ----- |
-- | "Bob" | 12  | 8     | 9     | 77      | 7     | 9     | 87    |

def fillna {n f a} (c:Label) (t:n=>{@c:(Maybe a) & ...f}) (v:a) : n=>{@c:a & ...f} =
  for i.
    {@c=ma, ...rest} = t.i
    case ma of
      Nothing -> {@c=v, ...rest}
      Just v  -> {@c=v, ...rest}

-- > fillna(studentsMissing, "favorite color", "white")
-- | name    | age | favorite color |
-- | ------- | --- | -------------- |
-- | "Bob"   |     | "blue"         |
-- | "Alice" | 17  | "green"        |
-- | "Eve"   | 13  | "white"        |
-- > fillna(gradebookMissing, "quiz1", 0)
-- | name    | age | quiz1 | quiz2 | midterm | quiz3 | quiz4 | final |
-- | ------- | --- | ----- | ----- | ------- | ----- | ----- | ----- |
-- | "Bob"   | 12  | 8     | 9     | 77      | 7     | 9     | 87    |
-- | "Alice" | 17  | 6     | 8     | 88      |       | 7     | 85    |
-- | "Eve"   | 13  | 0     | 9     | 84      | 8     | 8     | 77    |


'## Data Cleaning

'### TODO: `pivotLonger` (??)

-- This is a little difficult, because we'd need to reflect the labels as strings

-- ### `pivotLonger :: t1:Table * cs:Seq<ColName> * c1:ColName * c2:ColName -> t2:Table`
--
-- Reshapes the input table and make it longer. The data kept in the named columns are moved to two new columns, one for the column names and the other for the cell values.
--
-- > pivotLonger(gradebook, ["midterm", "final"], "exam", "score")
-- | name    | age | quiz1 | quiz2 | quiz3 | quiz4 | exam      | score |
-- | ------- | --- | ----- | ----- | ----- | ----- | --------- | ----- |
-- | "Bob"   | 12  | 8     | 9     | 7     | 9     | "midterm" | 77    |
-- | "Bob"   | 12  | 8     | 9     | 7     | 9     | "final"   | 87    |
-- | "Alice" | 17  | 6     | 8     | 8     | 7     | "midterm" | 88    |
-- | "Alice" | 17  | 6     | 8     | 8     | 7     | "final"   | 85    |
-- | "Eve"   | 13  | 7     | 9     | 8     | 8     | "midterm" | 84    |
-- | "Eve"   | 13  | 7     | 9     | 8     | 8     | "final"   | 77    |
-- > pivotLonger(gradebook, ["quiz1", "quiz2", "quiz3", "quiz4", "midterm", "final"], "test", "score")
-- | name    | age | test      | score |
-- | ------- | --- | --------- | ----- |
-- | "Bob"   | 12  | "quiz1"   | 8     |
-- | "Bob"   | 12  | "quiz2"   | 9     |
-- | "Bob"   | 12  | "quiz3"   | 7     |
-- | "Bob"   | 12  | "quiz4"   | 9     |
-- | "Bob"   | 12  | "midterm" | 77    |
-- | "Bob"   | 12  | "final"   | 87    |
-- | "Alice" | 17  | "quiz1"   | 6     |
-- | "Alice" | 17  | "quiz2"   | 8     |
-- | "Alice" | 17  | "quiz3"   | 8     |
-- | "Alice" | 17  | "quiz4"   | 7     |
-- | "Alice" | 17  | "midterm" | 88    |
-- | "Alice" | 17  | "final"   | 85    |
-- | "Eve"   | 13  | "quiz1"   | 7     |
-- | "Eve"   | 13  | "quiz2"   | 9     |
-- | "Eve"   | 13  | "quiz3"   | 8     |
-- | "Eve"   | 13  | "quiz4"   | 8     |
-- | "Eve"   | 13  | "midterm" | 84    |
-- | "Eve"   | 13  | "final"   | 77    |

'### TODO: `pivotWider` (lists of labels)

-- Note that this time the list of labels is in the table column
-- Not sure how to deal with that...

-- ### `pivotWider :: t1:Table * c1:ColName * c2:ColName -> t2:Table`
--
-- The inverse of `pivotLonger`.
--
-- > pivotWider(students, "name", "age")
-- | favorite color | Bob | Alice | Eve |
-- | -------------- | --- | ----- | --- |
-- | "blue"         | 12  |       |     |
-- | "green"        |     | 17    |     |
-- | "red"          |     |       | 13  |
-- > longerTable =
--     pivotLonger(
--       gradebook,
--       ["quiz1", "quiz2", "quiz3", "quiz4", "midterm", "final"],
--       "test",
--       "score")
-- > pivotWider(longerTable, "test", "score")
-- | name    | age | quiz1 | quiz2 | quiz3 | quiz4 | midterm | final |
-- | ------- | --- | ----- | ----- | ----- | ----- | ------- | ----- |
-- | "Bob"   | 12  | 8     | 9     | 7     | 9     | 77      | 87    |
-- | "Alice" | 17  | 6     | 8     | 8     | 7     | 88      | 85    |
-- | "Eve"   | 13  | 7     | 9     | 8     | 8     | 84      | 77    |

'## Utilities

'### TODO: `flatten` (fields map)

-- Can't zip multiple columns together... A typeclass could help.

def flatten (c:Label) (t:n=>{@c:m=>a & ...f}) : (n&m)=>{@c:a & ...f} = todo

-- ### `flatten :: t1:Table * cs:Seq<ColName> -> t2:Table`
--
-- When columns `cs` of table `t` have sequences, returns a `Table` where each element of each `c` in `cs` is flattened, meaning the column corresponding to `c` becomes a longer column where the original entries are concatenated. Elements of row `i` of `t` in columns other than `cs` will be repeated according to the length of `getValue(getRow(t1, i), c1)`. These lengths must therefore be the same for each `c` in `cs`.
--
-- > flatten(gradebookSeq, ["quizzes"])
-- | name    | age | quizzes | midterm | final |
-- | ------- | --- | ------- | ------- | ----- |
-- | "Bob"   | 12  | 8       | 77      | 87    |
-- | "Bob"   | 12  | 9       | 77      | 87    |
-- | "Bob"   | 12  | 7       | 77      | 87    |
-- | "Bob"   | 12  | 9       | 77      | 87    |
-- | "Alice" | 17  | 6       | 88      | 85    |
-- | "Alice" | 17  | 8       | 88      | 85    |
-- | "Alice" | 17  | 8       | 88      | 85    |
-- | "Alice" | 17  | 7       | 88      | 85    |
-- | "Eve"   | 13  | 7       | 84      | 77    |
-- | "Eve"   | 13  | 9       | 84      | 77    |
-- | "Eve"   | 13  | 8       | 84      | 77    |
-- | "Eve"   | 13  | 8       | 84      | 77    |
-- > t = buildColumn(gradebookSeq, "quiz-pass?",
--     function(r):
--       isPass =
--         function(n):
--           n >= 8
--         end
--       map(getValue(r, "quizzes"), isPass)
--     end)
-- > t
-- | name    | age | quizzes      | midterm | final | quiz-pass?                 |
-- | ------- | --- | ------------ | ------- | ----- | -------------------------- |
-- | "Bob"   | 12  | [8, 9, 7, 9] | 77      | 87    | [true, true, false, true]  |
-- | "Alice" | 17  | [6, 8, 8, 7] | 88      | 85    | [false, true, true, false] |
-- | "Eve"   | 13  | [7, 9, 8, 8] | 84      | 77    | [false, true, true, true]  |
-- > flatten(t, ["quiz-pass?", "quizzes"])
-- | name    | age | quizzes | midterm | final | quiz-pass? |
-- | ------- | --- | ------- | ------- | ----- | ---------- |
-- | "Bob"   | 12  | 8       | 77      | 87    | true       |
-- | "Bob"   | 12  | 9       | 77      | 87    | true       |
-- | "Bob"   | 12  | 7       | 77      | 87    | false      |
-- | "Bob"   | 12  | 9       | 77      | 87    | true       |
-- | "Alice" | 17  | 6       | 88      | 85    | false      |
-- | "Alice" | 17  | 8       | 88      | 85    | true       |
-- | "Alice" | 17  | 8       | 88      | 85    | true       |
-- | "Alice" | 17  | 7       | 88      | 85    | false      |
-- | "Eve"   | 13  | 7       | 84      | 77    | false      |
-- | "Eve"   | 13  | 9       | 84      | 77    | true       |
-- | "Eve"   | 13  | 8       | 84      | 77    | true       |
-- | "Eve"   | 13  | 8       | 84      | 77    | true       |

def transformColumn {n f a b} (c:Label) (t:n=>{@c:a & ...f}) (fn:a -> b) : n=>{@c:b & ...f} =
  for i.
    {@c=v, ...r} = t.i
    {@c=fn v, ...r}

-- > addLastName =
--     function(name):
--       concat(name, " Smith")
--     end
-- > transformColumn(students, "name", addLastName)
-- | name          | age | favorite color |
-- | ------------- | --- | -------------- |
-- | "Bob Smith"   | 12  | "blue"         |
-- | "Alice Smith" | 17  | "green"        |
-- | "Eve Smith"   | 13  | "red"          |
-- > quizScoreToPassFail =
--     function(score):
--       if score <= 6:
--         "fail"
--       else:
--         "pass"
--       end
--     end
-- > transformColumn(gradebook, "quiz1", quizScoreToPassFail)
-- | name    | age | quiz1  | quiz2 | midterm | quiz3 | quiz4 | final |
-- | ------- | --- | ------ | ----- | ------- | ----- | ----- | ----- |
-- | "Bob"   | 12  | "pass" | 9     | 77      | 7     | 9     | 87    |
-- | "Alice" | 17  | "fail" | 8     | 88      | 8     | 7     | 85    |
-- | "Eve"   | 13  | "pass" | 9     | 84      | 8     | 8     | 77    |

'### TODO: `renameColumns` (fields map)

def renameColumn (c:Label) (c':Label) (t:n=>{@c:a & ...f}) : n=>{@c':a & ...f} =
  for i.
    {@c=v, ...rest} = t.i
    {@c'=v, ...rest}

-- ### `renameColumns :: t1:Table * ccs:Seq<ColName * ColName> -> t2:Table`
-- > renameColumns(students, [("favorite color", "preferred color"), ("name", "first name")])
-- | first name | age | preferred color |
-- | ---------- | --- | --------------- |
-- | "Bob"      | 12  | "blue"          |
-- | "Alice"    | 17  | "green"         |
-- | "Eve"      | 13  | "red"           |
-- > renameColumns(gradebook, [("midterm", "final"), ("final", "midterm")])
-- | name    | age | quiz1 | quiz2 | final | quiz3 | quiz4 | midterm |
-- | ------- | --- | ----- | ----- | ----- | ----- | ----- | ------- |
-- | "Bob"   | 12  | 8     | 9     | 77    | 7     | 9     | 87      |
-- | "Alice" | 17  | 6     | 8     | 88    | 8     | 7     | 85      |
-- | "Eve"   | 13  | 7     | 9     | 84    | 8     | 8     | 77      |

def find [Eq a] (t:n=>a) (x:a) : Maybe n = todo

-- ### `find :: t:Table * r:Row -> n:Error<Number>`
-- > find(students, [row: ("age", 13)])
-- 2
-- > find(students, [row: ("age", 14)])
-- error("not found")

'### TODO: `groupByRetentive` (groupBy)

def groupByRetentive {n f a} (c:Label) (t:n=>{@c:a & ...f}) : List {key: a & groups:(List {@c:a & ...f})} = todo

-- ### `groupByRetentive :: t1:Table * c:ColName -> t2:Table`
-- > groupByRetentive(students, "favorite color")
-- | key     | groups                             |
-- | ------- | ---------------------------------- |
-- | "blue"  | | name    | age | favorite color | |
-- |         | | ------- | --- | -------------- | |
-- |         | | "Bob"   | 12  | "blue"         | |
-- | "green" | | name    | age | favorite color | |
-- |         | | ------- | --- | -------------- | |
-- |         | | "Alice" | 17  | "green"        | |
-- | "red"   | | name    | age | favorite color | |
-- |         | | ------- | --- | -------------- | |
-- |         | | "Eve"   | 13  | "red"          | |
-- > groupByRetentive(jellyAnon, "brown")
-- | key   | groups                                                                                  |
-- | ----- | --------------------------------------------------------------------------------------- |
-- | false | | get acne | red   | black | white | green | yellow | brown | orange | pink  | purple | |
-- |       | | -------- | ----- | ----- | ----- | ----- | ------ | ----- | ------ | ----- | ------ | |
-- |       | | true     | false | false | false | true  | false  | false | true   | false | false  | |
-- |       | | true     | false | true  | false | true  | true   | false | false  | false | false  | |
-- |       | | false    | false | false | false | true  | false  | false | false  | true  | false  | |
-- |       | | false    | false | false | false | false | true   | false | false  | false | false  | |
-- |       | | false    | false | false | false | false | true   | false | false  | true  | false  | |
-- |       | | true     | false | true  | false | false | false  | false | true   | true  | false  | |
-- |       | | false    | false | true  | false | false | false  | false | false  | true  | false  | |
-- |       | | true     | false | false | false | false | false  | false | true   | false | false  | |
-- | true  | | get acne | red   | black | white | green | yellow | brown | orange | pink  | purple | |
-- |       | | -------- | ----- | ----- | ----- | ----- | ------ | ----- | ------ | ----- | ------ | |
-- |       | | true     | false | false | false | false | false  | true  | true   | false | false  | |
-- |       | | false    | true  | false | false | false | true   | true  | false  | true  | false  | |

'### TODO: `groupBySubtractive` (groupBy)

def groupBySubtractive {n f a} (c:Label) (t:n=>{@c:a & ...f}) : List {key: a & groups:(List {&...f})} = todo
-- ### `groupBySubtractive :: t1:Table * c:ColName -> t2:Table`
--
-- Similar to `groupByRetentive` but the named column is removed in the output.
--
-- > groupBySubtractive(students, "favorite color")
-- | key     | groups            |
-- | ------- | ----------------- |
-- | "blue"  | | name    | age | |
-- |         | | ------- | --- | |
-- |         | | "Bob"   | 12  | |
-- | "green" | | name    | age | |
-- |         | | ------- | --- | |
-- |         | | "Alice" | 17  | |
-- | "red"   | | name    | age | |
-- |         | | ------- | --- | |
-- |         | | "Eve"   | 13  | |
-- > groupBySubtractive(jellyAnon, "brown")
-- | key   | groups                                                                          |
-- | ----- | ------------------------------------------------------------------------------- |
-- | false | | get acne | red   | black | white | green | yellow | orange | pink  | purple | |
-- |       | | -------- | ----- | ----- | ----- | ----- | ------ | ------ | ----- | ------ | |
-- |       | | true     | false | false | false | true  | false  | true   | false | false  | |
-- |       | | true     | false | true  | false | true  | true   | false  | false | false  | |
-- |       | | false    | false | false | false | true  | false  | false  | true  | false  | |
-- |       | | false    | false | false | false | false | true   | false  | false | false  | |
-- |       | | false    | false | false | false | false | true   | false  | true  | false  | |
-- |       | | true     | false | true  | false | false | false  | true   | true  | false  | |
-- |       | | false    | false | true  | false | false | false  | false  | true  | false  | |
-- |       | | true     | false | false | false | false | false  | true   | false | false  | |
-- | true  | | get acne | red   | black | white | green | yellow | orange | pink  | purple | |
-- |       | | -------- | ----- | ----- | ----- | ----- | ------ | ------ | ----- | ------ | |
-- |       | | true     | false | false | false | false | false  | true   | false | false  | |
-- |       | | false    | true  | false | false | false | true   | false  | true  | false  | |

'### TODO: `update` (???)

-- ### `update :: t1:Table * f:(r1:Row -> r2:Row) -> t2:Table`
--
-- Consumes an existing `Table` and produces a new `Table` with the named columns updated, using `f` to produce the values for those columns, once for each row.
--
-- > abstractAge =
--     function(r):
--       if (getValue(r, "age") <= 12):
--         [row: ("age", "kid")]
--       else if (getValue(r, "age") <= 19):
--         [row: ("age", "teenager")]
--       else:
--         [row: ("age", "adult")]
--       end
--     end
-- > update(students, abstractAge)
-- | name    | age        | favorite color |
-- | ------- | ---------- | -------------- |
-- | "Bob"   | "kid"      | "blue"         |
-- | "Alice" | "teenager" | "green"        |
-- | "Eve"   | "teenager" | "red"          |
-- > didWellInFinal =
--     function(r):
--       [row:
--         ("midterm", 85 <= getValue(r, "midterm"))
--         ("final", 85 <= getValue(r, "final"))]
--     end
-- > update(gradebook, didWellInFinal)
-- | name    | age | quiz1 | quiz2 | midterm | quiz3 | quiz4 | final |
-- | ------- | --- | ----- | ----- | ------- | ----- | ----- | ----- |
-- | "Bob"   | 12  | 8     | 9     | false   | 7     | 9     | true  |
-- | "Alice" | 17  | 6     | 8     | true    | 8     | 7     | true  |
-- | "Eve"   | 13  | 7     | 9     | false   | 8     | 8     | false |

def select' {n a b} (t:n=>a) (f:a -> n -> b) : n=>b = for i. f t.i i

:p select' students \{age, favColor, ..._} n.
  {ID=n, COLOR=favColor, age}
-- > select(
--     students,
--     function(r, n):
--       [row:
--         ("ID", n),
--         ("COLOR", getValue(r, "favorite color")),
--         ("AGE", getValue(r, "age"))]
--     end)
-- | ID | COLOR   | AGE |
-- | -- | ------- | --- |
-- | 0  | "blue"  | 12  |
-- | 1  | "green" | 17  |
-- | 2  | "red"   | 13  |

:p select' gradebook \{name, midterm, final, ..._} n.
  {full_name= concat [name, " Smith"], midterm_and_final_avg=(IToF (midterm + final)) / 2.0}
-- > select(
--     gradebook,
--     function(r, n):
--       [row:
--         ("full name", concat(getValue(r, "name"), " Smith")),
--         ("(midterm + final) / 2", (getValue(r, "midterm") + getValue(r, "final")) / 2)]
--     end)
-- | full name     | (midterm + final) / 2 |
-- | ------------- | --------------------- |
-- | "Bob Smith"   | 82                    |
-- | "Alice Smith" | 86.5                  |
-- | "Eve Smith"   | 80.5                  |

def selectMany (t:n=>a) (project:a -> n -> List b) (result:a -> b -> c) : List a =
  todo $ for i.
    AsList _ els = project t.i i
    for j. result t.i els.j

-- Projects each row of a table to a new table, flattens the resulting tables into one table, and invokes a result selector function on each row therein. The index of each source row is used in the intermediate projected form of that row.
--
-- > selectMany(
--     students,
--     function(r, n):
--       if even(n):
--         r
--       else:
--         head(r, 0)
--       end
--     end,
--     function(r1, r2):
--       r2
--     end)
-- | name  | age | favorite color |
-- | ----- | --- | -------------- |
-- | "Bob" | 12  | "blue"         |
-- | "Eve" | 13  | "red"          |
-- > repeatRow =
--     function(r, n):
--       if n == 0:
--         r
--       else:
--         addRows(repeatRow(r, n - 1), [r])
--       end
--     end
-- > selectMany(
--     gradebook,
--     repeatRow,
--     function(r1, r2):
--       selectColumns(r2, ["midterm"])
--     end)
-- | midterm |
-- | ------- |
-- | 77      |
-- | 88      |
-- | 88      |
-- | 84      |
-- | 84      |
-- | 84      |

'### TODO: `groupJoin` (groupBy)

-- ### `groupJoin<K> :: t1:Table * t2:Table * getKey1:(r1:Row -> k1:K) * getKey2:(r2:Row -> k2:K) * aggregate:(r3:Row * t3:Table -> r4:Row) -> t4:Table`
--
-- - `schema(r1)` is equal to `schema(t1)`
-- - `schema(r2)` is equal to `schema(t2)`
-- - `schema(r3)` is equal to `schema(t1)`
-- - `schema(t3)` is equal to `schema(t2)`
-- - `schema(t4)` is equal to `schema(r4)`
-- - `nrows(t4)` is equal to `nrows(t1)`
--
-- Correlates the rows of two tables based on equality of keys and groups the results.
--
-- > getName =
--     function(r):
--       getValue(r, "name")
--     end
-- > averageFinal =
--     function(r, t):
--       addColumn(r, "final", [average(getColumn(t, "final"))])
--     end
-- > groupJoin(students, gradebook, getName, getName, averageFinal)
-- | name    | age | favorite color | final |
-- | ------- | --- | -------------- | ----- |
-- | "Bob"   | 12  | "blue"         | 87    |
-- | "Alice" | 17  | "green"        | 85    |
-- | "Eve"   | 13  | "red"          | 77    |
-- > nameLength =
--     function(r):
--       length(getValue(r, "name"))
--     end
-- > tableNRows =
--     function(r, t):
--       addColumn(r, "nrows", [nrows(t)])
--     end
-- > groupJoin(students, gradebook, nameLength, nameLength, tableNRows)
-- | name    | age | favorite color | nrows |
-- | ------- | --- | -------------- | ----- |
-- | "Bob"   | 12  | "blue"         | 2     |
-- | "Alice" | 17  | "green"        | 1     |
-- | "Eve"   | 13  | "red"          | 2     |

def join [Eq key] (t1:n=>a) (t2:m=>b) (getKey1:a -> key) (getKey2:b -> key)
         (combine:a -> b -> c) : List c =
  concat $ for (i, j).
    case getKey1 t1.i == getKey2 t2.j of
      True  -> AsList _ [combine t1.i t2.j]
      False -> mempty

-- > getName =
--     function(r):
--       getValue(r, "name")
--     end
-- > addGradeColumn =
--     function(r1, r2):
--       addColumn(r1, "grade", [getValue(r2, "final")])
--     end
-- > join(students, gradebook, getName, getName, addGradeColumn)
-- | name    | age | favorite color | grade |
-- | ------- | --- | -------------- | ----- |
-- | "Bob"   | 12  | "blue"         | 87    |
-- | "Alice" | 17  | "green"        | 85    |
-- | "Eve"   | 13  | "red"          | 77    |
-- > nameLength =
--     function(r):
--       length(getValue(r, "name"))
--     end
-- > join(students, gradebook, nameLength, nameLength, addGradeColumn)
-- | name    | age | favorite color | grade |
-- | ------- | --- | -------------- | ----- |
-- | "Bob"   | 12  | "blue"         | 87    |
-- | "Bob"   | 12  | "blue"         | 77    |
-- | "Alice" | 17  | "green"        | 85    |
-- | "Eve"   | 13  | "red"          | 87    |
-- | "Eve"   | 13  | "red"          | 77    |

'# Buggy programs

'# License
Many comments in this file are derived from the [B2T2](https://github.com/brownplt/B2T2)
benchmark, which is licensed under MIT, so we reproduce the license.

-- MIT License
--
-- Copyright (c) 2022 Brown University PLT
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
