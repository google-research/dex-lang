' # Particle Swarm Optimizer

' ## Fitness function

rosenbrock : Float -> Float -> Float =
  \x y. sq (1.0 - x) + 80.0*sq (y - x*x)

' We write one that uses vector for input

rosenbrock2 : ((Fin 2)=>Float) -> Float =
  \xs.
    x = xs.(fromOrdinal _ 0)
    y = xs.(fromOrdinal _ 1)
    rosenbrock x y

' Min should be at 1.0, 1.0

:p rosenbrock 1.0 1.000
> 0.

:p rosenbrock2 [1.0, 1.000]
> 0.

:p rosenbrock 1.0 1.02
> 0.032

:p rosenbrock2 [1.0, 1.02]
> 0.032


' ## Helper functions

minbyfst : (Float & a) -> (Float & a) -> (Float & a) = minBy fst

minimumbyfst : (n=>(Float & a)) -> (Float & a) = minimumBy fst

' ### Rand helpers

' make a random vector uniformly distributed between `lb` and `ub`

randBounded : Key -> (d=>Float)->(d=>Float)->(d=>Float) =
  \key lb ub.
    for i. lb.i + ((rand $ ixkey key i) * (ub.i - lb.i))

:p randBounded (newKey 4) [1.0,  -2.0] [-1.0,  2.0]
> [-0.35101, 1.49355]

' ## The Optimizer itself.
We have **arguments**:
 - type explicit, `np:Ix`: number of particles
 - type explicit, `niter:Ix`: number of iterations
 - type: `d:Ix`: number of dimensions in the domain of `f`, i.e. the search space.
 - `f:(d=>Float)->Float`: loss function being minimized.
 - `(lb,ub):(d=>Float,d=>Float)`: boundries of the space being searched
 - `(momentum,gRate,pRate):(Float,Float,Float)`: PSO hyper-parameters to control exploration vs exploitation.

' **Returns**: the optimal point found with-in the bounds on the input domain of `f`.

def optimize
      (np':Int)                                        -- number of particles
      (niter:Int)                                      -- number of iterations
      (key:Key)                                        -- random seed
      (f:(d=>Float)->Float)                              -- function to optimize
      ((lb,ub):(d=>Float & d=>Float))                    -- bounds
      ((momentum, gRate, pRate):(Float & Float & Float))  -- momentum/pRate/gRate
      : (d=>Float) =
    np = Fin np'
    optStep = \(keyL, gbest, pbests, positions, velocities).
        newPositions:(np=>d=>Float) = positions + velocities
        newPbests:(np=>(Float & d=>Float)) = for p.
            minbyfst pbests.p (f newPositions.p, newPositions.p)
        newGbest:(Float & d=>Float) =
            minbyfst gbest (minimumbyfst newPbests)
        [keyG, keyP, keyNext] = splitKey keyL
        (gscore, gloc) = gbest
        plocs = map snd pbests
        gVel:(np=>d=>Float) = for p i.
            weight = rand $ (ixkey2 keyG p i)
            dir = gloc.i - positions.p.i
            weight * dir
        pVel:(np=>d=>Float) = for p i.
            weight = rand $ (ixkey2 keyP p i)
            dir = plocs.p.i - positions.p.i
            weight * dir
        newVelocities:(np=>d=>Float) = momentum .* velocities + gRate .* gVel + pRate .* gVel
        (keyNext,newGbest,newPbests,newPositions,newVelocities)
    randInit1 = \keyI1. randBounded keyI1 lb ub
    randInit  = \keyI. for p:np. randInit1 $ ixkey keyI p
    [keyPos, keyVel, keyLoop] = splitKey key
    initPositions:(np=>d=>Float) = randInit keyPos
    initVelocities:(np=>d=>Float) = randInit keyVel
    initPs:(np=>(Float & d=>Float)) = for p. (f initPositions.p, initPositions.p)
    initG:(Float & d=>Float) = minimumbyfst initPs
    inits = (keyLoop,initG,initPs,initPositions,initVelocities)
    res = fold inits (\iter:(Fin niter). optStep)
    (dc0,(finalGscore, finalGloc),dc1,dc2,dc3) = res
    finalGloc

' ---
Lets see how it goes.
Run it for more iterations and result should improve.
Which it indeed does.

:p optimize 50 10 (newKey 0) rosenbrock2 ([-10.0, -10.0],[20.0, 20.0]) (0.5,0.3,0.4)
> [0.076986, 0.232818]

:p optimize 50 20 (newKey 0) rosenbrock2 ([-10.0, -10.0],[20.0, 20.0]) (0.5,0.3,0.4)
> [0.90125, 0.750447]

:p optimize 50 100 (newKey 0) rosenbrock2 ([-10.0, -10.0],[20.0, 20.0]) (0.5,0.3,0.4)
> [0.999069, 0.998192]

:p optimize 50 1000 (newKey 0) rosenbrock2 ([-10.0, -10.0],[20.0, 20.0]) (0.5,0.3,0.4)
> [1., 1.]
