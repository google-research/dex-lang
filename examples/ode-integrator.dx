'## Euler Integrator
Using only generic vector operations.

Time : Type = Real

def eulerStep (dict: VSpace a) ?=>
              (zref: Ref h a) ->
              (dynamics: a -> Time -> a) ->
              (dt: Time) ->
              (t: Time)
              : {State h} Unit =
    z = get zref
    zref := z + dt .* dynamics z t

def euler (dict: VSpace a) ?=> 
          (dynamics: a -> Time -> a) ->
          (z0: a) ->
          (t0: Time) ->
          (t1: Time) ->
          (dt: Time)
          : a =
     n = floor ((t1 - t0) / dt)
     snd $ withState z0 \zref.
       for i:(Fin n).
         t = t0 + (i2r (ordinal i)) * dt
         eulerStep zref dynamics dt t

def myDyn (dict: VSpace a) ?=> 
          (z : a) -> (t:Time) : a = z

z0 = [1.0]
t0 = 0.0
t1 = 1.0
dt = 0.0001

:p euler myDyn z0 t0 t1 dt
> [2.7182682]

:plot
  xsTest = linspace (Fin 100) 0.0 1.0
  zip xsTest $ map (\t1. sum $ euler myDyn z0 t0 t1 dt) xsTest
