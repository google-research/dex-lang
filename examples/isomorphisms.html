<!DOCTYPE HTML>
<html><head><style type="text/css">/*Copyright2019GoogleLLC*//**//*UseofthissourcecodeisgovernedbyaBSD-style*//*licensethatcanbefoundintheLICENSEfileorat*//*https://developers.google.com/open-source/licenses/bsd*/body{margin:1emauto1emauto;padding:1em1em1em1em;max-width:50em;font-family:Helvetica,sans-serif;font-size:100%;color:#333;padding-bottom:500px;}.cell{}.code-block,.err-block,.result-block{padding:0em0em0em2em;display:block;font-family:monospace;white-space:pre;}code{background-color:#F0F0F0;}.result-block{border-left:3pxsolid#87CEFA;}.prose-block{line-height:140%;}.err-block{font-weight:bold;color:#B22222;border-left:3pxsolid#B22222;}.plot{padding:5em;}.plot-img{width:80%;}.comment{color:#808080;}.keyword{color:#0000DD;}.command{color:#A80000;}.symbol{color:#E07000;}.type-name{color:#A80000;}.iso-sugar{color:#25BBA7;}</style><meta charset="UTF-8"></head><body><div id="main-output"><div class="cell"><div class="prose-block"><h1>Isomorphisms in Dex</h1>
</div></div><div class="cell"><div class="prose-block"><p><code>Iso a b</code> is the type of an isomorphism between <code>a</code> and <code>b</code>.</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> <span class="type-name">MkIso</span>
</div><div class="result-block">((a:Type) ?-&gt; (b:Type) ?-&gt; {bwd: b -&gt; a &amp; fwd: a -&gt; b} -&gt; Iso a b)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>This is a normal ADT, and you can construct your own isomorphisms.</p>
</div></div><div class="cell"><div class="code-block">cycleThree <span class="symbol">:</span> <span class="type-name">Iso</span> (a <span class="symbol">&amp;</span> b <span class="symbol">&amp;</span> c) (b <span class="symbol">&amp;</span> c <span class="symbol">&amp;</span> a) <span class="symbol">=</span>
  <span class="type-name">MkIso</span> { fwd <span class="symbol">=</span> <span class="symbol">\</span>(a<span class="symbol">,</span> b<span class="symbol">,</span> c)<span class="symbol">.</span> (b<span class="symbol">,</span> c<span class="symbol">,</span> a)
        <span class="symbol">,</span> bwd <span class="symbol">=</span> <span class="symbol">\</span>(b<span class="symbol">,</span> c<span class="symbol">,</span> a)<span class="symbol">.</span> (a<span class="symbol">,</span> b<span class="symbol">,</span> c)
        }
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Isomorphisms can be applied with <code>appIso</code>, applied in reverse with <code>revIso</code>,
and flipped with <code>flipIso</code></p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> appIso cycleThree (1<span class="symbol">,</span> 2<span class="symbol">.</span>0<span class="symbol">,</span> 3)
</div><div class="result-block">(2.0, (3, 1))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> revIso cycleThree (1<span class="symbol">,</span> 2<span class="symbol">.</span>0<span class="symbol">,</span> 3)
</div><div class="result-block">(3, (1, 2.0))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> appIso (flipIso cycleThree) (1<span class="symbol">,</span> 2<span class="symbol">.</span>0<span class="symbol">,</span> 3)
</div><div class="result-block">(3, (1, 2.0))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>They can also be composed with <code>&amp;&gt;&gt;</code>:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> appIso (cycleThree <span class="symbol">&amp;&gt;&gt;</span> cycleThree) (1<span class="symbol">,</span> 2<span class="symbol">.</span>0<span class="symbol">,</span> 3)
</div><div class="result-block">(3, (1, 2.0))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> appIso (cycleThree <span class="symbol">&amp;&gt;&gt;</span> cycleThree <span class="symbol">&amp;&gt;&gt;</span> cycleThree) (1<span class="symbol">,</span> 2<span class="symbol">.</span>0<span class="symbol">,</span> 3)
</div><div class="result-block">(1, (2.0, 3))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Note that we assume but do not check that the isomorphism is lawful (i.e.
<code>appIso iso $ revIso iso x == x</code> for all <code>x</code>, or equivalently
<code>iso &amp;&gt;&gt; (flipIso iso) == idIso</code>).</p>
</div></div><div class="cell"><div class="prose-block"><p>In addition, Dex will automatically write some useful isomorphisms for you
to extract fields from records and variants. There are four syntactic forms
that produce isos. We will start with the first two:</p>
<ul>
<li><code>#x</code> produces a &quot;lens-like&quot; record accessor <code>Iso {x:a &amp; ...r} (a &amp; {&amp;...r})</code></li>
<li><code>#?x</code> produces a &quot;prism-like&quot; variant matcher <code>Iso {x:a | ...r} (a | {|...r})</code></li>
</ul>
</div></div><div class="cell"><div class="code-block">%passes parse
<span class="command">:t</span> <span class="iso-sugar">#b</span> <span class="symbol">:</span> <span class="type-name">Iso</span> {a<span class="symbol">:</span><span class="type-name">Int</span> <span class="symbol">&amp;</span> b<span class="symbol">:</span><span class="type-name">Float</span> <span class="symbol">&amp;</span> c<span class="symbol">:</span><span class="type-name">Unit</span>} _
</div><div class="result-block">(Iso {a: Int32 &amp; b: Float32 &amp; c: Unit} (Float32 &amp; {a: Int32 &amp; c: Unit}))</div><div class="result-block">=== parse ===
_ans_ =
  MkIso {bwd = \(x, r). {b = x, ...r}, fwd = \{b = x, ...r}. (,) x r}
  : Iso {a: Int &amp; b: Float &amp; c: Unit} _
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block">%passes parse
<span class="command">:t</span> <span class="iso-sugar">#?b</span> <span class="symbol">:</span> <span class="type-name">Iso</span> {a<span class="symbol">:</span><span class="type-name">Int</span> <span class="symbol">|</span> b<span class="symbol">:</span><span class="type-name">Float</span> <span class="symbol">|</span> c<span class="symbol">:</span><span class="type-name">Unit</span>} _
</div><div class="result-block">(Iso {a: Int32 | b: Float32 | c: Unit} (Float32 | {a: Int32 | c: Unit}))</div><div class="result-block">=== parse ===
_ans_ =
  MkIso
    { bwd = \v. case v
                ((Left x)) -&gt; {| b = x |}
                ((Right r)) -&gt; {|b| ...r |}
                
    , fwd = \v. case v
                {| b = x |} -&gt; (Left x)
                {|b| ...r |} -&gt; (Right r)
                }
  : Iso {a: Int | b: Float | c: Unit} _
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>There are also two &quot;zipper&quot; forms, described later on this page:</p>
<ul>
<li><code>#&amp;x</code> produces a &quot;record-zipper&quot; isomorphism
<pre><code>Iso ({&amp;...l} &amp; {x:a &amp; ...r}) ({x:a &amp; ...l} &amp; {&amp;...r})
</code></pre>
</li>
<li><code>#|x</code> produces a &quot;variant-zipper&quot; isomorphism
<pre><code>Iso ({|...l} | {x:a | ...r}) ({x:a | ...l} | {|...r})
</code></pre>
</li>
</ul>
</div></div><div class="cell"><div class="prose-block"><h2>Record accessors and lens-like helpers</h2>
<p>Record accessor isomorphisms can be passed into the helper function <code>getAt</code>:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> getAt
</div><div class="result-block">((a:Type) ?-&gt; (b:Type) ?-&gt; (c:Type) ?-&gt; (Iso a (b &amp; c)) -&gt; a -&gt; b)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> getAt <span class="iso-sugar">#foo</span> {foo<span class="symbol">=</span>1<span class="symbol">,</span> bar<span class="symbol">=</span>2<span class="symbol">.</span>0}
</div><div class="result-block">1</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>We can also do other types of things:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> popAt <span class="iso-sugar">#foo</span> {foo<span class="symbol">=</span>1<span class="symbol">,</span> bar<span class="symbol">=</span>2<span class="symbol">.</span>0}
</div><div class="result-block">{bar = 2.0}</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> pushAt <span class="iso-sugar">#foo</span> 3<span class="symbol">.</span>0 {foo<span class="symbol">=</span>1<span class="symbol">,</span> bar<span class="symbol">=</span>2<span class="symbol">.</span>0}
</div><div class="result-block">{bar = 2.0, foo = 3.0, foo = 1}</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> setAt <span class="iso-sugar">#foo</span> 2 {foo<span class="symbol">=</span>1<span class="symbol">,</span> bar<span class="symbol">=</span>2<span class="symbol">.</span>0}
</div><div class="result-block">{bar = 2.0, foo = 2}</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>These helper functions work with any &quot;lens-like&quot; isomorphism. For instance,
we can select everything except for a particular field:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> exceptLens
</div><div class="result-block">((a:Type) ?-&gt; (b:Type) ?-&gt; (c:Type) ?-&gt; (Iso a (b &amp; c)) -&gt; Iso a (c &amp; b))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> getAt (exceptLens <span class="iso-sugar">#foo</span>) {foo<span class="symbol">=</span>1<span class="symbol">,</span> bar<span class="symbol">=</span>2<span class="symbol">.</span>0<span class="symbol">,</span> baz<span class="symbol">=</span>3}
</div><div class="result-block">{bar = 2.0, baz = 3}</div></div><div class="cell"><div class="code-block">

</div></div><div class="cell"><div class="prose-block"><h2>Variant accessors and prism-like helpers</h2>
<p>Similarly, there are prism-like helpers</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> matchWith
</div><div class="result-block">((a:Type) ?-&gt; (b:Type) ?-&gt; (c:Type) ?-&gt; (Iso a (b | c)) -&gt; a -&gt; Maybe b)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> buildWith
</div><div class="result-block">((a:Type) ?-&gt; (b:Type) ?-&gt; (c:Type) ?-&gt; (Iso a (b | c)) -&gt; b -&gt; a)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>which can be used with variant accessors or any other prism-like isomorphism:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> matchWith <span class="iso-sugar">#?foo</span> <span class="symbol">$</span> {<span class="symbol">|</span>foo <span class="symbol">=</span> 1<span class="symbol">|</span>}<span class="symbol">:</span>{foo<span class="symbol">:</span><span class="type-name">Int</span> <span class="symbol">|</span> bar<span class="symbol">:</span><span class="type-name">Float</span>}
</div><div class="result-block">(Just 1)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> matchWith <span class="iso-sugar">#?foo</span> <span class="symbol">$</span> {<span class="symbol">|</span>bar <span class="symbol">=</span> 1<span class="symbol">.</span>0<span class="symbol">|</span>}<span class="symbol">:</span>{foo<span class="symbol">:</span><span class="type-name">Int</span> <span class="symbol">|</span> bar<span class="symbol">:</span><span class="type-name">Float</span>}
</div><div class="result-block">Nothing</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> buildWith <span class="iso-sugar">#?foo</span> 3 <span class="symbol">:</span> {foo<span class="symbol">:</span><span class="type-name">Int</span> <span class="symbol">|</span> bar<span class="symbol">:</span><span class="type-name">Float</span>}
</div><div class="result-block">{| foo = 3 |}</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> matchWith (exceptPrism <span class="iso-sugar">#?foo</span>) <span class="symbol">$</span>  {<span class="symbol">|</span>bar <span class="symbol">=</span> 1<span class="symbol">.</span>0<span class="symbol">|</span>}<span class="symbol">:</span>{foo<span class="symbol">:</span><span class="type-name">Int</span> <span class="symbol">|</span> bar<span class="symbol">:</span><span class="type-name">Float</span>}
</div><div class="result-block">(Just {| bar = 1.0 |})</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><h2>Record zipper isomorphisms</h2>
<p>The isomorphisms shown above are specialized for removing a single field from
an object. As such, they don't compose well when trying to work with more than
one field at a time. When using multiple fields, a better choice is to use
a &quot;zipper isomorphism&quot;, which moves a subset of fields from one place to
another. For instance:</p>
</div></div><div class="cell"><div class="code-block">%passes parse
<span class="command">:t</span> <span class="iso-sugar">#&amp;a</span> <span class="symbol">:</span> <span class="type-name">Iso</span> ({<span class="symbol">&amp;</span>} <span class="symbol">&amp;</span> {a<span class="symbol">:</span><span class="type-name">Int</span> <span class="symbol">&amp;</span> b<span class="symbol">:</span><span class="type-name">Float</span> <span class="symbol">&amp;</span> c<span class="symbol">:</span><span class="type-name">Unit</span>}) _
</div><div class="result-block">(Iso
   ({ &amp;} &amp; {a: Int32 &amp; b: Float32 &amp; c: Unit})
   ({a: Int32} &amp; {b: Float32 &amp; c: Unit}))</div><div class="result-block">=== parse ===
_ans_ =
  MkIso
    { bwd = \({a = x, ...l}, {, ...r}). (,) {, ...l} {a = x, ...r}
    , fwd = \({, ...l}, {a = x, ...r}). (,) {a = x, ...l} {, ...r}}
  : Iso ((&amp;) { &amp;} {a: Int &amp; b: Float &amp; c: Unit}) _
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> (<span class="iso-sugar">#&amp;a</span> <span class="symbol">&amp;&gt;&gt;</span> <span class="iso-sugar">#&amp;b</span>) <span class="symbol">:</span> <span class="type-name">Iso</span> ({<span class="symbol">&amp;</span>} <span class="symbol">&amp;</span> {a<span class="symbol">:</span><span class="type-name">Int</span> <span class="symbol">&amp;</span> b<span class="symbol">:</span><span class="type-name">Float</span> <span class="symbol">&amp;</span> c<span class="symbol">:</span><span class="type-name">Unit</span>}) _
</div><div class="result-block">(Iso
   ({ &amp;} &amp; {a: Int32 &amp; b: Float32 &amp; c: Unit})
   ({a: Int32 &amp; b: Float32} &amp; {c: Unit}))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p><code>#&amp;a</code> and <code>#&amp;b</code> are isomorphisms that move a given field from the record on the
right to the record on the left; when composed, they move both fields.</p>
</div></div><div class="cell"><div class="prose-block"><p>The main use for record zipper isomorphisms is to specify multiple named axes
when using a record type as an index set:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> overFields
</div><div class="result-block">((a:Type)
 ?-&gt; (b:Type)
 ?-&gt; (c:Type)
 ?-&gt; (v:Type) ?-&gt; (Iso ({ &amp;} &amp; a) (b &amp; c)) -&gt; (a =&gt; v) -&gt; b =&gt; c =&gt; v)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="comment">-- :p
</span></div></div><div class="cell"><div class="code-block"><span class="comment">--   x = for {a, b, c}:{a:Fin 2 &amp; b:Fin 2 &amp; c:Fin 2}.
</span></div></div><div class="cell"><div class="code-block"><span class="comment">--     ordinal a * 100 + ordinal b * 10 + ordinal c
</span></div></div><div class="cell"><div class="code-block"><span class="comment">--   v1 = x
</span></div></div><div class="cell"><div class="code-block"><span class="comment">--   v2 = sum $ overFields (#&amp;b) x
</span></div></div><div class="cell"><div class="code-block"><span class="comment">--   v3 = sum $ overFields (#&amp;b &amp;&gt;&gt; #&amp;c) x
</span></div></div><div class="cell"><div class="code-block"><span class="comment">--   v4 = sum $ overFields (#&amp;a &amp;&gt;&gt; #&amp;b &amp;&gt;&gt; #&amp;c) x
</span></div></div><div class="cell"><div class="code-block"><span class="comment">--   (v1, v2, v3, v4)
</span></div></div><div class="cell"><div class="code-block"><span class="comment">-- &gt; ( [0, 100, 10, 110, 1, 101, 11, 111]@{a: Fin 2 &amp; b: Fin 2 &amp; c: Fin 2}
</span></div></div><div class="cell"><div class="code-block"><span class="comment">-- &gt; , ([10, 210, 12, 212]@{a: Fin 2 &amp; c: Fin 2}, ([22, 422]@{a: Fin 2}, [444]@{ &amp;})) )
</span></div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p>Note that <code>overFields</code> is just a simple wrapper combining <code>splitR</code> and
<code>overLens</code>:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> splitR
</div><div class="result-block">((a:Type) ?-&gt; Iso a ({ &amp;} &amp; a))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> overLens
</div><div class="result-block">((a:Type)
 ?-&gt; (b:Type)
 ?-&gt; (c:Type) ?-&gt; (v:Type) ?-&gt; (Iso a (b &amp; c)) -&gt; (a =&gt; v) -&gt; b =&gt; c =&gt; v)</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p><code>overLens</code> alone can be used with any lens-like isomorphism, for instance an
ordinary record accessor lens.</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span>
  x <span class="symbol">=</span> <span class="keyword">for</span> {a<span class="symbol">,</span> b<span class="symbol">,</span> c}<span class="symbol">:</span>{a<span class="symbol">:</span><span class="type-name">Fin</span> 2 <span class="symbol">&amp;</span> b<span class="symbol">:</span><span class="type-name">Fin</span> 2 <span class="symbol">&amp;</span> c<span class="symbol">:</span><span class="type-name">Fin</span> 2}<span class="symbol">.</span>
    ordinal a <span class="symbol">*</span> 100 <span class="symbol">+</span> ordinal b <span class="symbol">*</span> 10 <span class="symbol">+</span> ordinal c
  overLens <span class="iso-sugar">#a</span> x
</div><div class="result-block">[ [0, 10, 1, 11]@{b: Fin 2 &amp; c: Fin 2}
, [100, 110, 101, 111]@{b: Fin 2 &amp; c: Fin 2} ]</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p><code>splitR</code> can be used if you want to process multiple fields at once:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> pushAt (splitR <span class="symbol">&amp;&gt;&gt;</span> <span class="iso-sugar">#&amp;a</span> <span class="symbol">&amp;&gt;&gt;</span> <span class="iso-sugar">#&amp;b</span>) {a<span class="symbol">=</span>1<span class="symbol">,</span> b<span class="symbol">=</span>2<span class="symbol">.</span>0} {c<span class="symbol">=</span>3<span class="symbol">,</span> d<span class="symbol">=</span>4<span class="symbol">.</span>0}
</div><div class="result-block">{a = 1, b = 2.0, c = 3, d = 4.0}</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><h2>Variant zipper isomorphisms</h2>
<p>Just as there are record zipper isomorphisms, there are also variant
zipper isomorphisms:</p>
</div></div><div class="cell"><div class="code-block">%passes parse
<span class="command">:t</span> <span class="iso-sugar">#|a</span> <span class="symbol">:</span> <span class="type-name">Iso</span> ({<span class="symbol">|</span>} <span class="symbol">|</span> {a<span class="symbol">:</span><span class="type-name">Int</span> <span class="symbol">|</span> b<span class="symbol">:</span><span class="type-name">Float</span> <span class="symbol">|</span> c<span class="symbol">:</span><span class="type-name">Unit</span>}) _
</div><div class="result-block">(Iso
   ({ |} | {a: Int32 | b: Float32 | c: Unit})
   ({a: Int32} | {b: Float32 | c: Unit}))</div><div class="result-block">=== parse ===
_ans_ =
  MkIso
    { bwd = \v. case v
                ((Left w)) -&gt; (case w
                                 {| a = x |} -&gt; (Right {| a = x |})
                                 {|a| ...r |} -&gt; (Left r)
                                 )
                ((Right l)) -&gt; (Right {|a| ...l |})
                
    , fwd = \v. case v
                ((Left l)) -&gt; (Left {|a| ...l |})
                ((Right w)) -&gt; (case w
                                  {| a = x |} -&gt; (Left {| a = x |})
                                  {|a| ...r |} -&gt; (Right r)
                                  )
                }
  : Iso ((|) { |} {a: Int | b: Float | c: Unit}) _
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p><code>splitV</code> makes a prism zipper into an ordinary prism isomorphism:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:t</span> splitV
</div><div class="result-block">((a:Type) ?-&gt; Iso a ({ |} | a))</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span>
  vals <span class="symbol">:</span> (<span class="type-name">Fin</span> 3)<span class="symbol">=&gt;</span>{a<span class="symbol">:</span>_ <span class="symbol">|</span> b<span class="symbol">:</span>_ <span class="symbol">|</span> c<span class="symbol">:</span>_ } <span class="symbol">=</span> [{<span class="symbol">|</span>a <span class="symbol">=</span> 1<span class="symbol">|</span>}<span class="symbol">,</span> {<span class="symbol">|</span>b <span class="symbol">=</span> 2<span class="symbol">|</span>}<span class="symbol">,</span> {<span class="symbol">|</span>c <span class="symbol">=</span> 3<span class="symbol">|</span>}]
  <span class="keyword">for</span> i<span class="symbol">.</span> matchWith (splitV <span class="symbol">&amp;&gt;&gt;</span> <span class="iso-sugar">#|a</span> <span class="symbol">&amp;&gt;&gt;</span> <span class="iso-sugar">#|b</span>) vals<span class="symbol">.</span>i
</div><div class="result-block">[(Just {| a = 1 |}), (Just {| b = 2 |}), Nothing]</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="prose-block"><p><code>sliceFields</code> uses this to specific named variants from a variant-indexed
table:</p>
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span>
  x <span class="symbol">=</span> iota {a<span class="symbol">:</span><span class="type-name">Fin</span> 2 <span class="symbol">|</span> b<span class="symbol">:</span><span class="type-name">Fin</span> 2 <span class="symbol">|</span> c<span class="symbol">:</span><span class="type-name">Fin</span> 2}
  v1 <span class="symbol">=</span> x
  v2 <span class="symbol">=</span> sliceFields (<span class="iso-sugar">#|b</span>) x
  v3 <span class="symbol">=</span> sliceFields (<span class="iso-sugar">#|a</span> <span class="symbol">&amp;&gt;&gt;</span> <span class="iso-sugar">#|c</span>) x
  v4 <span class="symbol">=</span> sliceFields (<span class="iso-sugar">#|a</span> <span class="symbol">&amp;&gt;&gt;</span> <span class="iso-sugar">#|b</span> <span class="symbol">&amp;&gt;&gt;</span> <span class="iso-sugar">#|c</span>) x
  (v1<span class="symbol">,</span> v2<span class="symbol">,</span> v3<span class="symbol">,</span> v4)
</div><div class="result-block">( [0, 1, 2, 3, 4, 5]@{a: Fin 2 | b: Fin 2 | c: Fin 2}
, ( [2, 3]@{b: Fin 2}
, ( [0, 1, 4, 5]@{a: Fin 2 | c: Fin 2}
, [0, 1, 2, 3, 4, 5]@{a: Fin 2 | b: Fin 2 | c: Fin 2} ) ) )</div></div></div></body></html>