<!DOCTYPE HTML>
<html><head><style type="text/css">/*Copyright2019GoogleLLC*//**//*UseofthissourcecodeisgovernedbyaBSD-style*//*licensethatcanbefoundintheLICENSEfileorat*//*https://developers.google.com/open-source/licenses/bsd*/body{margin:1emauto1emauto;padding:1em1em1em1em;max-width:50em;font-family:Helvetica,sans-serif;font-size:100%;color:#333;padding-bottom:500px;}.cell{}.code-block,.err-block,.result-block{padding:0em0em0em2em;display:block;font-family:monospace;white-space:pre;}code{background-color:#F0F0F0;}.result-block{border-left:3pxsolid#87CEFA;}.prose-block{line-height:140%;}.err-block{font-weight:bold;color:#B22222;border-left:3pxsolid#B22222;}.plot{padding:5em;}.plot-img{width:80%;}.comment{color:#808080;}.keyword{color:#0000DD;}.command{color:#A80000;}.symbol{color:#E07000;}.type-name{color:#A80000;}.iso-sugar{color:#25BBA7;}</style><meta charset="UTF-8"></head><body><div id="main-output"><div class="cell"><div class="prose-block"><h2>Connectionist Temporal Classification</h2>
<p>By Alex Graves et alia.</p>
</div></div><div class="cell"><div class="prose-block"><p><a href="https://www.cs.toronto.edu/%7Egraves/icml_2006.pdf">Link to paper</a>.</p>
</div></div><div class="cell"><div class="prose-block"><p>This dynamic programming algorithm computes the probability of a particular sequences of labels
(without pauses included) given another sequence of label probabilities
(with pauses included), marginalizing over all possible combination of
pause lengths.
It's used for training speech-to-text models on unaligned training data.</p>
</div></div><div class="cell"><div class="prose-block"><p>Most implementations of CTC compute the marginal logprob
and its gradients combining a forward and a backward pass.
However, as mentioned in the original paper, we should only
need the last step of the forward pass to compute the marginal
probability, and Dex's autodiff should produce the backward
pass automatically.  That makes this code much shorter than
most implementations.</p>
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> interleave (blank<span class="command">:v</span>) (labels<span class="symbol">:</span> m<span class="symbol">=&gt;</span>v) <span class="symbol">:</span> (m <span class="symbol">&amp;</span> (<span class="type-name">Fin</span> 2))<span class="symbol">=&gt;</span>v <span class="symbol">=</span>
  <span class="comment">-- Turns &quot;text&quot; into &quot;t e x t &quot; by first pairing each letter with a blank,
</span>  <span class="comment">-- then flattening the pairs back into a single-index table.
</span>  pairs <span class="symbol">=</span> <span class="keyword">for</span> i<span class="symbol">.</span> [labels<span class="symbol">.</span>i<span class="symbol">,</span> blank]
  <span class="keyword">for</span> (i<span class="symbol">,</span> j)<span class="symbol">.</span> pairs<span class="symbol">.</span>i<span class="symbol">.</span>j
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> prepend (first<span class="symbol">:</span> v) (seq<span class="symbol">:</span> m<span class="symbol">=&gt;</span>v) <span class="symbol">:</span> ({head<span class="symbol">:</span><span class="type-name">Unit</span> <span class="symbol">|</span> tail<span class="command">:m</span> }<span class="symbol">=&gt;</span>v) <span class="symbol">=</span>
  <span class="comment">-- Concatenates a single element to the beginning of a sequence.
</span>  <span class="keyword">for</span> idx<span class="symbol">.</span> <span class="keyword">case</span> idx <span class="keyword">of</span>
    {<span class="symbol">|</span> head <span class="symbol">=</span> () <span class="symbol">|</span>} <span class="symbol">-&gt;</span> first
    {<span class="symbol">|</span> tail <span class="symbol">=</span> i  <span class="symbol">|</span>} <span class="symbol">-&gt;</span> seq<span class="symbol">.</span>i
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> prepend_and_interleave (blank<span class="command">:v</span>) (seq<span class="symbol">:</span> m<span class="symbol">=&gt;</span>v) <span class="symbol">:</span>
  ({head<span class="symbol">:</span><span class="type-name">Unit</span> <span class="symbol">|</span> tail<span class="symbol">:</span>(m <span class="symbol">&amp;</span> (<span class="type-name">Fin</span> 2))}<span class="symbol">=&gt;</span>v) <span class="symbol">=</span>
  <span class="comment">-- Turns &quot;text&quot; into &quot; t e x t&quot;.
</span>  <span class="comment">-- The output of this function has a slightly complicated output type, which
</span>  <span class="comment">-- has size 1 + 2 * (size m).
</span>  interleaved <span class="symbol">=</span> interleave blank seq
  prepend blank interleaved
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> clipidx (n<span class="symbol">:</span><span class="type-name">Type</span>) <span class="symbol">-&gt;</span> (i<span class="symbol">:</span><span class="type-name">Int</span>) <span class="symbol">:</span> n <span class="symbol">=</span>
  <span class="comment">-- Returns element at 0 if less than zero.
</span>  <span class="comment">-- Ideally we could have an alternative
</span>  <span class="comment">-- to Fin that just clips the index at its bounds.
</span>  fromOrdinal n (select (i <span class="symbol">&lt;</span> 0) 0 i)
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> logaddexp (x<span class="symbol">:</span><span class="type-name">Float</span>) (y<span class="symbol">:</span><span class="type-name">Float</span>) <span class="symbol">:</span> <span class="type-name">Float</span> <span class="symbol">=</span>
  m <span class="symbol">=</span> max x y
  m <span class="symbol">+</span> ( log ( (exp (x <span class="symbol">-</span> m) <span class="symbol">+</span> exp (y <span class="symbol">-</span> m))))
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> ctc (dict<span class="symbol">:</span> <span class="type-name">Eq</span> vocab) <span class="symbol">?=&gt;</span> (dict2<span class="symbol">:</span> <span class="type-name">Eq</span> position) <span class="symbol">?=&gt;</span> (dict3<span class="symbol">:</span> <span class="type-name">Eq</span> time) <span class="symbol">?=&gt;</span> (blank<span class="symbol">:</span> vocab)
        (logits<span class="symbol">:</span> time<span class="symbol">=&gt;</span>vocab<span class="symbol">=&gt;</span><span class="type-name">Float</span>) (labels<span class="symbol">:</span> position<span class="symbol">=&gt;</span>vocab) <span class="symbol">:</span> <span class="type-name">Float</span> <span class="symbol">=</span>
  <span class="comment">-- Computes log p(labels | logits), marginalizing over possible alignments.
</span>  <span class="comment">-- Todo: remove unnecessary implicit type annotations once
</span>  <span class="comment">-- Dex starts putting implicit types in scope.
</span>
  ilabels <span class="symbol">=</span> prepend_and_interleave blank labels

  normalized_logits <span class="symbol">=</span> <span class="keyword">for</span> t<span class="symbol">.</span> logsoftmax logits<span class="symbol">.</span>t

  <span class="comment">-- Initialization rules
</span>  logprob_start_with_blank <span class="symbol">=</span> normalized_logits<span class="symbol">.</span>(0<span class="symbol">@</span>_)<span class="symbol">.</span>blank
  logprob_<span class="keyword">of</span>_first_label   <span class="symbol">=</span> normalized_logits<span class="symbol">.</span>(0<span class="symbol">@</span>_)<span class="symbol">.</span>(labels<span class="symbol">.</span>(0<span class="symbol">@</span>_))
  log_prob_seq_t0 <span class="symbol">=</span> <span class="keyword">for</span> pos<span class="symbol">.</span>
    <span class="comment">-- TODO: allow pattern-matching on integer literals
</span>    <span class="keyword">case</span> ordinal pos <span class="symbol">==</span> 0 <span class="keyword">of</span>
      <span class="type-name">True</span> <span class="symbol">-&gt;</span> logprob_start_with_blank
      <span class="type-name">False</span> <span class="symbol">-&gt;</span> <span class="keyword">case</span> ordinal pos <span class="symbol">==</span> 1 <span class="keyword">of</span>
        <span class="type-name">True</span>  <span class="symbol">-&gt;</span> logprob_<span class="keyword">of</span>_first_label
        <span class="type-name">False</span> <span class="symbol">-&gt;</span> log 0<span class="symbol">.</span>000001

  same_as_last <span class="symbol">=</span> <span class="symbol">\</span>ilabels s<span class="symbol">.</span>
    o <span class="symbol">=</span> ordinal s
    select (o <span class="symbol">&gt;=</span> 2) (ilabels<span class="symbol">.</span>s <span class="symbol">==</span> ilabels<span class="symbol">.</span>(clipidx _ (o <span class="symbol">-</span> 2))) <span class="type-name">False</span>

  safe_idx <span class="symbol">=</span> <span class="symbol">\</span>prev s<span class="symbol">.</span>
    select (s <span class="symbol">&gt;=</span> 0) prev<span class="symbol">.</span>(clipidx _ s) (log 0<span class="symbol">.</span>0)

  <span class="comment">-- Todo: As suggested by Adam Paske, we could get rid of these
</span>  <span class="comment">-- logaddexp calls with a newtype that overloads + and *
</span>  update <span class="symbol">=</span> <span class="symbol">\</span>t prev<span class="symbol">.</span>
    <span class="keyword">case</span> ordinal t <span class="symbol">==</span> 0 <span class="keyword">of</span>
      <span class="type-name">True</span> <span class="symbol">-&gt;</span> log_prob_seq_t0
      <span class="type-name">False</span> <span class="symbol">-&gt;</span> <span class="keyword">for</span> s<span class="symbol">.</span>
        cond <span class="symbol">=</span> ilabels<span class="symbol">.</span>s <span class="symbol">==</span> blank <span class="symbol">||</span> same_as_last ilabels s
        labar <span class="symbol">=</span> logaddexp prev<span class="symbol">.</span>s (safe_idx prev ((ordinal s) <span class="symbol">-</span> 1))
        other <span class="symbol">=</span> logaddexp labar  (safe_idx prev ((ordinal s) <span class="symbol">-</span> 2))
        ans <span class="symbol">=</span> select cond labar other
        ans <span class="symbol">+</span> normalized_logits<span class="symbol">.</span>t<span class="symbol">.</span>(ilabels<span class="symbol">.</span>s)

  log_prob_seq_final <span class="symbol">=</span> fold log_prob_seq_t0 update

  <span class="comment">-- Todo: nicer way to get last two elements of log_prob_seq_final.
</span>  seq_length <span class="symbol">=</span> 1 <span class="symbol">+</span> size (position <span class="symbol">&amp;</span> (<span class="type-name">Fin</span> 2))
  endlabel <span class="symbol">=</span> log_prob_seq_final<span class="symbol">.</span>((seq_length <span class="symbol">-</span> 2)<span class="symbol">@</span>_)
  endspace <span class="symbol">=</span> log_prob_seq_final<span class="symbol">.</span>((seq_length <span class="symbol">-</span> 1)<span class="symbol">@</span>_)
  logaddexp endlabel endspace
</div></div><div class="cell"><div class="code-block">

</div></div><div class="cell"><div class="prose-block"><h3>Demo</h3>
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> randIdxNoZero (n<span class="symbol">:</span><span class="type-name">Type</span>) <span class="symbol">-&gt;</span> (k<span class="symbol">:</span><span class="type-name">Key</span>) <span class="symbol">:</span> n <span class="symbol">=</span>
  unif <span class="symbol">=</span> rand k
  fromOrdinal n <span class="symbol">$</span> (1 <span class="symbol">+</span> (<span class="type-name">FToI</span> (floor ( unif <span class="symbol">*</span> <span class="type-name">IToF</span> ((size n) <span class="symbol">-</span> 1)))))
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="type-name">Vocab</span> <span class="symbol">=</span> <span class="type-name">Fin</span> 6
</div></div><div class="cell"><div class="code-block">position <span class="symbol">=</span> <span class="type-name">Fin</span> 3
</div></div><div class="cell"><div class="code-block">blank <span class="symbol">=</span> 0<span class="symbol">@</span><span class="type-name">Vocab</span>
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="comment">-- Create random logits
</span></div></div><div class="cell"><div class="code-block"><span class="type-name">Time</span> <span class="symbol">=</span> <span class="type-name">Fin</span> 4
</div></div><div class="cell"><div class="code-block">logits <span class="symbol">:</span> <span class="type-name">Time</span> <span class="symbol">=&gt;</span> <span class="type-name">Vocab</span> <span class="symbol">=&gt;</span> <span class="type-name">Float</span> <span class="symbol">=</span> arb <span class="symbol">$</span> newKey 0
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="comment">-- Create random labels
</span></div></div><div class="cell"><div class="code-block">labels <span class="symbol">=</span> <span class="keyword">for</span> i<span class="command">:position</span><span class="symbol">.</span> randIdxNoZero <span class="type-name">Vocab</span> (newKey (ordinal i))
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> labels
</div><div class="result-block">[(1@Fin 6), (5@Fin 6), (5@Fin 6)]</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="comment">-- Evaluate marginal probability of labels given logits
</span></div></div><div class="cell"><div class="code-block"><span class="command">:p</span> exp <span class="symbol">$</span> ctc blank logits labels
</div><div class="result-block">1.0398488e-3</div></div><div class="cell"><div class="code-block">


</div></div><div class="cell"><div class="prose-block"><h3>Test</h3>
</div></div><div class="cell"><div class="code-block"><span class="comment">-- Check that the sum of p(labels|logits) sums to 1.0 over all possible labels.
</span></div></div><div class="cell"><div class="code-block"><span class="comment">-- They don&#39;t yet sum to one, however I&#39;m not 100% sure about the
</span></div></div><div class="cell"><div class="code-block"><span class="comment">-- semantics of the marginal likelihood being computed, and whether
</span></div></div><div class="cell"><div class="code-block"><span class="comment">-- e.g. the summed-over labels should include blanks.
</span></div></div><div class="cell"><div class="code-block">

</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> sum <span class="keyword">for</span> i<span class="symbol">:</span><span class="type-name">Vocab</span><span class="symbol">.</span>
  exp <span class="symbol">$</span> ctc blank logits [i]
</div><div class="result-block">0.14146839</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> sum <span class="keyword">for</span> (i<span class="symbol">,</span> j)<span class="symbol">:</span>(<span class="type-name">Vocab</span> <span class="symbol">&amp;</span> <span class="type-name">Vocab</span>)<span class="symbol">.</span>
  exp <span class="symbol">$</span> ctc blank logits [i<span class="symbol">,</span> j]
</div><div class="result-block">0.7091234</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> sum <span class="keyword">for</span> (i<span class="symbol">,</span> j<span class="symbol">,</span> k)<span class="symbol">:</span>(<span class="type-name">Vocab</span> <span class="symbol">&amp;</span> <span class="type-name">Vocab</span> <span class="symbol">&amp;</span> <span class="type-name">Vocab</span>)<span class="symbol">.</span>
  exp <span class="symbol">$</span> ctc blank logits [i<span class="symbol">,</span> j<span class="symbol">,</span> k]
</div><div class="result-block">0.9251011</div></div></div></body></html>