''''''''''''''''''''
Prelude to the tests
''''''''''''''''''''

%passes rename
effect Exn
  raise : a: Type ?-> Unit -> a

-- handler {r} catch_ : Exn returning (Maybe r)
--   def-handle raise {a} (_:Unit) = Nothing
--   def-return (x: r) = Just x
--
-- def assert_ (b: Bool) : {Exn} Unit =
--   if not b then raise ()
--
-- ''''''''''''''''''''
-- Same as exception-tests.dx, but with user-defined effects
-- ''''''''''''''''''''
--
-- def checkFloatInUnitInterval (x:Float) : {Exn} Float =
--   assert_ $ x >= 0.0
--   assert_ $ x <= 1.0
--   x
--
-- :p catch_ do assert_ False
-- > Nothing
--
-- :p catch_ do assert_ True
-- > (Just ())
--
-- :p catch_ do checkFloatInUnitInterval 1.2
-- > Nothing
--
-- :p catch_ do checkFloatInUnitInterval (-1.2)
-- > Nothing
--
-- :p catch_ do checkFloatInUnitInterval 0.2
-- > (Just 0.2)
--
-- :p yield_state 0 \ref.
--      catch_ do
--        ref := 1
--        assert_ False
--        ref := 2
-- > 1
--
-- :p catch_ do
--   for i:(Fin 5).
--     if ordinal i > 3
--       then raise ()
--       else 23
-- > Nothing
--
-- :p catch_ do
--   for i:(Fin 3).
--     if ordinal i > 3
--       then raise ()
--       else 23
-- > (Just [23, 23, 23])
--
-- -- Is this the result we want?
-- :p yield_state zero \ref.
--      catch_ do
--        for i:(Fin 6).
--          if (ordinal i `rem` 2) == 0
--            then raise ()
--            else ()
--          ref!i := 1
-- > [0, 1, 0, 1, 0, 1]
--
-- :p catch_ do
--      run_state 0 \ref.
--        ref := 1
--        assert_ False
--        ref := 2
-- > Nothing
--
