
:p 3 + (4 + 5)
> 12

def depId(a:Type, x:a) -> a = x

:p depId Int 1
> 1

def returnFirstArg(a:Type, b:Type, x:a, y:b) -> a = x

:p returnFirstArg Int Float 1 2.0
> 1

:p 1.0 + 2.0
> 3.

def triple(x:Float) -> Float = x + x + x

:p triple 1.0
> 3.

def idExplicit(a:Type, x:a) -> a = x

:p idExplicit Int 1
> 1

def idImplicit(x:a) -> a given (a:Type) = x
:p idImplicit 1
> 1

idImplicit2 : (given (a:Type), a) -> a = \x. x
:p idImplicit2 1
> 1

:p
  idImplicit3 : (given (a:Type), a) -> a = \x. x
  idImplicit3 1
> 1

:p (\x y. x + y) 1.0 2.0
> 3.

:p 1.0 + 1
> 2.

:p 1 + (1.0 + 2.0)
> 4.

:p 1.0 + (2 + 3)
> 6.

:p x + x
> Error: variable not in scope: x
>
> :p x + x
>    ^^

idiv = 1
> Error: variable already defined: idiv
>
> idiv = 1
> ^^^^^

def TyId(a:Type) -> Type = a
:p
  x:(TyId Int) = 1
  x
> 1

:p
  def TyId2(a:Type) -> Type = a
  x:(TyId2 Int) = 1
  x
> 1

def tabId(x:n=>Int) -> n=>Int given (n|Ix) = for i. x[i]

-- bug: this doesn't work if we split it across top-level decls
:p
  xs = for i:(Fin 3) . 1
  tabId xs
> [1, 1, 1]

myPair = (1, 2.3)

:p fst myPair
> 1

:p
   yield_state 2 \s.
     x = get s
     s := x + 3
> 5

:p
   yield_state 1 \s.
     for i:(Fin 10).
       x = get s
       s := x + x
> 1024

:p
 x:() = ()
 x
> ()

:p [1,2,3]
> [1, 2, 3]

:p
  x : Fin 0 => Int = []
  x
> []


:p
  x : (Fin 3, Fin 2) => Int = coerce_table((Fin 3, Fin 2), [1, 2, 3, 4, 5, 6])
  x
> [1, 2, 3, 4, 5, 6]

:p [] :: (Fin 0 => Int)
> []

:p coerce_table (Fin 2, Fin 2) [1, 2, 3, 4]
> [1, 2, 3, 4]


:p sin 1.01
> 0.8468319

:p
  (x,y) = (1,2)
  (x,y)
> (1, 2)

:p
  (x,y,z) = (1,2,3)
  (x,y,z)
> (1, 2, 3)

-- XXX: This is an ambiguous type error with overloaded literals
-- TODO: Reenable once we have reasonable error messages for ambiguous types
-- :p
--   ((x,y),z) = (1,2,3)
--   ((x,y),z)
-- > Type error:
-- > Expected: (a & b)
-- >   Actual: Int32
-- > (Solving for: [a:Type, b:Type])
-- >
-- >   ((x,y),z) = (1,2,3)
-- >     ^^^

:p
  (x,y,z) = (1,2,3)
  (x,y,z)
> (1, 2, 3)

-- XXX: This is an ambiguous type error with overloaded literals
-- TODO: Reenable once we have reasonable error messages for ambiguous types
-- :p
--   (x,y) = 1
--   (x,y)
-- > Type error:
-- > Expected: (a & b)
-- >   Actual: Int32
-- > (Solving for: [a:Type, b:Type])
-- >
-- >   (x,y) = 1
-- >    ^^^

:p
  yield_state [1,2,3] \xsRef.
    for i:(Fin 3).
      xsRef!i := ordinal i
> [0, 1, 2]

def passthrough(f:(a)->{|eff} b, x:a) -> {|eff} b
    given (a, b, eff:Effects) =
  f x

:p
  yield_state 1 \ref.
    passthrough (\_. ref := 10) ()
> 10

:p
  run_state 0 \r1.
    run_state 0 \r2.
      r1 := 1
      r2 := 2
> (((), 2), 1)

:p (\f x y. f x y) (+) 1.0 2.0
> 3.

:p
  myId = fst (\x. x, 2)
  f : (aa:Type, aa) -> aa = \bb x. myId x
  f Int 1
> Leaked local variables:[bb]
> Failed to exchange binders in buildAbsInf
> Pending emissions: 
> Defaults:  
> Solver substitution: [(_.3, bb)]
>
>   f : (aa:Type, aa) -> aa = \bb x. myId x
>                             ^^^^^^^^^^^^^

def myFst(p:(a,b)) -> a given (a, b) =
  (x, _) = p
  x
:p myFst (1,2)
> 1

def myOtherFst(pair:(a,b)) -> a given (a, b) =
  (x, _) = pair
  x
:p myOtherFst (1,2)
> 1

:p sum [1.,2.]
> 3.

:p
  xs = fanout 1.0
  for i:(Fin 3). xs[i]+ xs[i]
> [2., 2., 2.]

:p
   f = \x. x * x * x
   jvp f 2.0 1.5
> 18.

:p
   f : (Float) -> Float =
     \x. 2.0 * (x + x)
   transpose_linear(f)(1.0)
> 4.

-- FIXME: This fails due to shadowing!
--def transpose' (x:n=>m=>Float) --o : m=>n=>Float = for i j. x.j.i
--
--:p transpose_linear transpose' [[1.0, 2.0, 3.0]]
--> [[1.0], [2.0], [3.0]]

:p
   f : (Float) -> (Fin 3=>Float) =
     \x. for i. x * 2.0
   transpose_linear(f)([1.0, 2.0, 3.0])
> 12.

id'' : (given (b:Type), b) -> b = id

def eitherFloor(x:(Either Int Float)) -> Int = case x of
  Left  i -> i
  Right f -> f_to_i f

:p (eitherFloor (Left 1), eitherFloor (Right 2.3))
> (1, 2)

-- Needs delayed inference (can't verify Ix and reduce the type before we infer the hole).
-- :p [1, 2, 3, 4] : ((Fin _ & Fin 2) => Int)
-- > Type error:
-- > Expected: ((Fin a & Fin 2) => Int32)
-- >   Actual: ((Fin 4) => b)
-- > (Solving for: [a, b])
-- > If attempting to construct a fixed-size table not indexed by 'Fin n' for some n, this error may indicate there was not enough information to infer a concrete index set; try adding an explicit annotation.
-- >
-- > :p [1, 2, 3, 4] : ((Fin _ & Fin 2) => Int)
-- >    ^^^^^^^^^^^^^

:p
  [(a, b), c] = [(1, 2), (3, 4)]
  (a, c)
> (1, (3, 4))

:p
  [a, b] = [1, 2, 3]
  (a, b)
> Type error:
> Expected: ((Fin 3) => a)
>   Actual: ((Fin 2) => b)
> (Solving for: [a, b])
>
>   [a, b] = [1, 2, 3]
>   ^^^^^^^

:p
  [[a, _], [_, d]] = [[1, 2], [3, 4]]
  a + d
> 5

-- Can only unpack tables indexed by `Fin n`
:p
  [a, b, c, d] = coerce_table (Fin 2, Fin 2) [1, 2, 3, 4]
  (a, b, c, d)
> Type error:
> Expected: ((Fin 2, Fin 2) => a)
>   Actual: ((Fin 4) => b)
> (Solving for: [a, b])
>
>   [a, b, c, d] = coerce_table (Fin 2, Fin 2) [1, 2, 3, 4]
>   ^^^^^^^^^^^^^

-- Needs delayed inference (can't verify Ix and reduce the type before we infer the hole).
-- :p
--   [a, b, c, d] = zero :: (_ => Int)
--   (a, b, c, d)
-- > (0, (0, (0, 0)))

def bug(n|Data) -> () =
  for w':n.
    w : n = todo
    for i:(w..). ()
  ()
> Leaked local variables:[v#0]
> Block:
>  v#0:n = todo n (synthesize (Data n))
>  v#1:((RangeFrom n v#0) => ()) = for i:(RangeFrom n v#0). ()
>  v#1
> Of type: ((RangeFrom n v#0) => ())
> With effects: {}
>
>   for w':n.
>   ^^^^^^^^^^

badDefinition = oops_there_is_a_problem
> Error: variable not in scope: oops_there_is_a_problem
>
> badDefinition = oops_there_is_a_problem
>                 ^^^^^^^^^^^^^^^^^^^^^^^

badDefinition = 4
> Error: variable already defined: badDefinition
>
> badDefinition = 4
> ^^^^^^^^^^^^^^

:p badDefinition
> Error: ambiguous variable: badDefinition is defined:
> in this file
> in this file
>
>
> :p badDefinition
>    ^^^^^^^^^^^^^
