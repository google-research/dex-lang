
'## Dex prelude

'Runs before every Dex program unless an alternative is provided with `--prelude`.

'Wrappers around primitives

Unit = %UnitType
Type = %TyKind
Effects = %EffKind
Fields = %LabeledRowKind

Int64 = %Int64
Int32 = %Int32
Int8  = %Int8
Float64 = %Float64
Float32 = %Float32

Int = Int64
Float = Float64

def (&) (a:Type) (b:Type) : Type = %PairType a b
def (,) (x:a) (y:b) : (a & b) = %pair x y
def fst (p: (a & b)) : a = %fst p
def snd (p: (a & b)) : b = %snd p

def idiv (x:Int) (y:Int) : Int = %idiv x y
def rem  (x:Int) (y:Int) : Int = %irem x y
def ipow (x:Int) (y:Int) : Int = %ipow x y

def fdiv (x:Float) (y:Float) : Float = %fdiv x y

def internalCast (b:Type) (x:a) : b = %cast b x

def F64ToF (x : Float64) : Float   = internalCast _ x
def F32ToF (x : Float32) : Float   = internalCast _ x
def FToF64 (x : Float)   : Float64 = internalCast _ x
def FToF32 (x : Float)   : Float32 = internalCast _ x
def I64ToI (x : Int64)   : Int     = internalCast _ x
def I32ToI (x : Int32)   : Int     = internalCast _ x
def I8ToI  (x : Int8 )   : Int     = internalCast _ x
def IToI64 (x : Int)     : Int64   = internalCast _ x
def IToI32 (x : Int)     : Int32   = internalCast _ x
def IToI8  (x : Int)     : Int8    = internalCast _ x

data Add a:Type =
  MkAdd (a->a->a) (a->a->a) a  -- add, sub, zero

def (+)  (d:Add a) ?=> : a -> a -> a = case d of MkAdd add _   _    -> add
def (-)  (d:Add a) ?=> : a -> a -> a = case d of MkAdd _   sub _    -> sub
def zero (d:Add a) ?=> : a           = case d of MkAdd _   _   zero -> zero

@instance float64Add : Add Float64 = MkAdd (\x:Float64 y:Float64. %fadd x y) (\x y. %fsub x y) (FToF64 0.0)
@instance float32Add : Add Float32 = MkAdd (\x:Float32 y:Float32. %fadd x y) (\x y. %fsub x y) (FToF32 0.0)
@instance int64Add   : Add Int64   = MkAdd (\x:Int64   y:Int64.   %iadd x y) (\x y. %isub x y) (IToI64 0)
@instance int32Add   : Add Int32   = MkAdd (\x:Int32   y:Int32.   %iadd x y) (\x y. %isub x y) (IToI32 0)
@instance int8Add    : Add Int8    = MkAdd (\x:Int8    y:Int8.    %iadd x y) (\x y. %isub x y) (IToI8  0)
@instance unitAdd    : Add Unit    = MkAdd (\x y. ())                        (\x y. ())        ()

@instance tabAdd : Add a ?=> Add (n=>a) =
  (MkAdd ( \xs ys. for i. xs.i + ys.i )
         ( \xs ys. for i. xs.i - ys.i )
         ( for _. zero ))

data Mul a:Type = MkMul (a->a->a) a  -- multiply, one

def (*) (d:Mul a) ?=> : a -> a -> a = case d of MkMul mul _   -> mul
def one (d:Mul a) ?=> : a           = case d of MkMul _   one -> one

@instance floatMul : Mul Float = MkMul (\x:Float y:Float. %fmul x y) 1.0
@instance intMul   : Mul Int   = MkMul (\x:Int   y:Int.   %imul x y) 1
@instance unitMul  : Mul Unit  = MkMul (\x y. ()) ()

data VSpace a:Type = MkVSpace (Add a) (Float -> a -> a)

@superclass
def addFromVSpace (d:VSpace a) : Add a = case d of MkVSpace addDict _ -> addDict

flip : (a -> b -> c) -> (b -> a -> c) = \f x y. f y x
uncurry : (a -> b -> c) -> (a & b) -> c = \f (x,y). f x y
const : a -> b -> a = \x _. x

def (.*)  (d:VSpace a) ?=> : Float -> a -> a = case d of MkVSpace _ scale -> scale
(*.)  : VSpace a ?=> a -> Float -> a = flip (.*)
def (/) (_:VSpace a) ?=> (v:a) (s:Float) : a = (fdiv 1.0 s) .* v
def neg (_:VSpace a) ?=> (v:a) : a = (-1.0) .* v

@instance floatVS : VSpace Float = MkVSpace float64Add (*)
@instance tabVS  : VSpace a ?=> VSpace (n=>a) = MkVSpace tabAdd \s xs. for i. s .* xs.i
@instance unitVS : VSpace Unit = MkVSpace unitAdd \s u. ()

data Bool =
  False
  True

def BToI8 (x : Bool) : Int8 =
  case x of
    False -> (IToI8 0)
    True  -> (IToI8 1)

def I8ToB (x : Int8) : Bool =
  t = True
  f = False
  %select x t f

def (&&) (x:Bool) (y:Bool) : Bool =
  x' = BToI8 x
  y' = BToI8 y
  I8ToB $ %and x' y'

def (||) (x:Bool) (y:Bool) : Bool =
  x' = BToI8 x
  y' = BToI8 y
  I8ToB $ %or x' y'

def not  (x:Bool) : Bool =
  x' = BToI8 x
  I8ToB $ %not x'

'Sum types

data Maybe a:Type =
  Nothing
  Just a

def isNothing (x:Maybe a) : Bool = case x of
  Nothing -> True
  Just _ -> False

data (|) a:Type b:Type =
  Left  a
  Right b

def select (p:Bool) (x:a) (y:a) : a = case p of
  True  -> x
  False -> y

def b2i (x:Bool) : Int  =
  case x of
    False -> 0
    True  -> 1

def IToF (x:Int) : Float = internalCast _ x
def FToI (x:Float) : Int = internalCast _ x
def b2r (x:Bool) : Float = IToF (b2i x)
def todo (a:Type) ?-> : a = %throwError a

'Effects

def Ref (r:Type) (a:Type) : Type = %Ref r a
def get  (ref:Ref h s)       : {State h} s    = %get  ref
def (:=) (ref:Ref h s) (x:s) : {State h} Unit = %put  ref x
def ask  (ref:Ref h r)       : {Read  h} r    = %ask  ref
def (+=) (ref:Ref h w) (x:w) : {Accum h} Unit = %tell ref x
def (!)  (ref:Ref h (n=>a)) (i:n) : Ref h a = %indexRef ref i
def fstRef (ref: Ref h (a & b)) : Ref h a = %fstRef ref
def sndRef (ref: Ref h (a & b)) : Ref h b = %sndRef ref

def withReader
      (eff:Effects) ?-> (a:Type) ?-> (r:Type) ?->
      (init:r) (action: (h:Type ?-> Ref h r -> {Read h|eff} a))
      : {|eff} a =
    def explicitAction (h':Type) (ref:Ref h' r) : {Read h'|eff} a = action ref
    %runReader init explicitAction

def withAccum
      (eff:Effects) ?-> (a:Type) ?-> (w:Type) ?->
      (action: (h:Type ?-> Ref h w -> {Accum h|eff} a))
      : {|eff} (a & w) =
    def explicitAction (h':Type) (ref:Ref h' w) : {Accum h'|eff} a = action ref
    %runWriter explicitAction

def withState
      (eff:Effects) ?-> (a:Type) ?-> (s:Type) ?->
      (init:s)
      (action: (h:Type ?-> Ref h s -> {State h |eff} a))
      : {|eff} (a & s) =
    def explicitAction (h':Type) (ref:Ref h' s) : {State h'|eff} a = action ref
    %runState init explicitAction

'Type classes

data Eq  a:Type = MkEq  (a -> a -> Bool)
data Ord a:Type = MkOrd (Eq a) (a -> a -> Bool) (a -> a -> Bool)  -- eq, gt, lt

@superclass
def eqFromOrd (d:Ord a) : Eq a = case d of MkOrd eq _ _ -> eq

def (==) (d:Eq a) ?=> (x:a) (y:a) : Bool = case d of MkEq eq -> eq x y
def (/=) (d:Eq a) ?=> (x:a) (y:a) : Bool = not $ x == y

def (>)  (d:Ord a) ?=> (x:a) (y:a) : Bool = case d of MkOrd _ gt _  -> gt x y
def (<)  (d:Ord a) ?=> (x:a) (y:a) : Bool = case d of MkOrd _ _  lt -> lt x y
def (<=) (d:Ord a) ?=> (x:a) (y:a) : Bool = x<y || x==y
def (>=) (d:Ord a) ?=> (x:a) (y:a) : Bool = x>y || x==y

@instance intEq   : Eq Int   = MkEq \x:Int   y:Int.   I8ToB $ %ieq x y
@instance floatEq : Eq Float = MkEq \x:Float y:Float. I8ToB $ %feq x y
@instance unitEq  : Eq Unit  = MkEq \x y. True

@instance intOrd  : Ord Int  = (MkOrd intEq  (\x y. I8ToB $ %igt x y)
                                             (\x y. I8ToB $ %ilt x y))
@instance floatOrd : Ord Float = (MkOrd floatEq (\x y. I8ToB $ %fgt x y)
                                                (\x y. I8ToB $ %flt x y))
@instance unitOrd : Ord Unit = MkOrd unitEq (\x y. False) (\x y. False)

@instance
def pairEq (eqA: Eq a)?=> (eqB: Eq b)?=> : Eq (a & b) = MkEq $
  \(x1,x2) (y1,y2). x1 == y1 && x2 == y2

@instance
def pairOrd (ordA: Ord a)?=> (ordB: Ord b)?=> : Ord (a & b) =
  pairGt = \(x1,x2) (y1,y2). x1 > y1 || (x1 == y1 && x2 > y2)
  pairLt = \(x1,x2) (y1,y2). x1 < y1 || (x1 == y1 && x2 < y2)
  MkOrd pairEq pairGt pairLt

-- TODO: accumulate using the True/&& monoid
@instance
def tabEq (n:Type) ?-> (eqA: Eq a) ?=> : Eq (n=>a) = MkEq $
  \xs ys.
    numDifferent : Float =
      snd $ withAccum \ref. for i.
        ref += (IToF (b2i (xs.i /= ys.i)))
    numDifferent == 0.0

'Wrappers around C library functions

def exp (x:Float) : Float = %exp x
def exp2 (x:Float) : Float = %exp2 x
def log (x:Float) : Float = %log x
def log2 (x:Float) : Float = %log2 x
def log10 (x:Float) : Float = %log10 x

def sin (x:Float) : Float = %sin x
def cos (x:Float) : Float = %cos x
def tan (x:Float) : Float = %tan x

def floor (x:Float) : Float = %floor x
def ceil  (x:Float) : Float = %ceil x
def round (x:Float) : Float = %round x

def sqrt (x:Float) : Float = %sqrt x
def pow (x:Float) (y:Float) : Float = %fpow x y

def lgamma (x:Float) : Float =
  x64 = FToF64 x
  F64ToF $ %ffi lgamma Float64 x64
def log1p  (x:Float) : Float =
  x64 = FToF64 x
  F64ToF $ %ffi log1p  Float64 x64
def lbeta (x:Float) (y:Float) : Float = lgamma x + lgamma y - lgamma (x + y)

'Working with index sets

def Range (low:Int) (high:Int) : Type = %IntRange low high
def Fin (n:Int) : Type = Range 0 n
def ordinal (i:a) : Int = %asint i
def size (n:Type) : Int = %idxSetSize n
def fromOrdinal (n:Type) (i:Int) : n = %asidx n i
def asidx (n:Type) ?-> (i:Int) : n = fromOrdinal n i
def (@) (i:Int) (n:Type) : n = fromOrdinal n i
def ixadd (n:Type) ?-> (i:n) (x:Int) : n = fromOrdinal n $ ordinal i + x
def ixsub (n:Type) ?-> (i:n) (x:Int) : n = fromOrdinal n $ ordinal i - x
def iota (n:Type) : n=>Int = for i. ordinal i

-- TODO: we want Eq and Ord for all index sets, not just `Fin n`
@instance
def finEq (n:Int) ?-> : Eq (Fin n) = MkEq \x y. ordinal x == ordinal y

@instance
def finOrd (n:Int) ?-> : Ord (Fin n) =
  MkOrd finEq (\x y. ordinal x > ordinal y) (\x y. ordinal x < ordinal y)

'Misc

pi : Float = 3.141592653589793

def id (x:a) : a = x
def dup (x:a) : (a & a) = (x, x)
-- TODO: unpack pair in args once we fix the bug
def swap (p:(a&b)) : (b&a) = (snd p, fst p)
def map (f:a->{|eff} b) (xs: n=>a) : {|eff} (n=>b) = for i. f xs.i
def zip (xs:n=>a) (ys:n=>b) : (n=>(a&b)) = for i. (xs.i, ys.i)
def unzip (xys:n=>(a&b)) : (n=>a & n=>b) = (map fst xys, map snd xys)
def fanout (n:Type) (x:a) : n=>a = for i. x
def sq (d:Mul a) ?=> (x:a) : a = x * x
def abs (x:Float) : Float = select (x > 0.0) x (-x)
def mod (x:Int) (y:Int) : Int = rem (y + rem x y) y
def compose (f:b->c) (g:a->b) (x:a) : c = f (g x)

def reverse (x:n=>a) : n=>a =
  s = size n
  for i. x.((s - 1 - ordinal i)@_)

def slice (xs:n=>a) (start:Int) (m:Type) : m=>a =
  for i. xs.(fromOrdinal _ (ordinal i + start))

def scan (init:a) (body:n->a->(a&b)) : (a & n=>b) =
  swap $ withState init \s. for i.
    c = get s
    (c', y) = body i c
    s := c'
    y

def fold (init:a) (body:(n->a->a)) : a = fst $ scan init \i x. (body i x, ())
def reduce (identity:a) (binop:(a->a->a)) (xs:n=>a) : a =
  -- `binop` should be a commutative and associative, and form a
  -- commutative monoid with `identity`
  -- TODO: implement with a parallelizable monoid-parameterized writer
  fold identity (\i c. binop c xs.i)

-- TODO: call this `scan` and call the current `scan` something else
def scan' (init:a) (body:n->a->a) : n=>a = snd $ scan init \i x. dup (body i x)
-- TODO: allow tables-via-lambda and get rid of this
def fsum (xs:n->Float) : Float = snd $ withAccum \ref. for i. ref += xs i
def sum  (_: Add v) ?=> (xs:n=>v) : v = reduce zero (+) xs
def prod (_: Mul v) ?=> (xs:n=>v) : v = reduce one  (*) xs
def mean (n:Type) ?-> (xs:n=>Float) : Float = sum xs / IToF (size n)
def std (xs:n=>Float) : Float = sqrt $ mean (map sq xs) - sq (mean xs)
def any (xs:n=>Bool) : Bool = reduce False (||) xs
def all (xs:n=>Bool) : Bool = reduce True  (&&) xs

def while
    (eff:Effects) ?->
    (cond: Unit -> {|eff} Bool)
    (body: Unit -> {|eff} Unit)
    : {|eff} Unit =
  cond' : Unit -> {|eff} Int8 = \_. BToI8 $ cond ()
  %while cond' body

data IterResult a:Type b:Type =
  Continue a
  Done b

-- A little iteration combinator
-- TODO: allow effects (currently there's some type inference bug preventing it)
def iter (init:a) (body: Int -> a -> IterResult a b) : b  =
  result = snd $ withState Nothing \resultRef.
    withState init \carryRef.
      withState 0 \i.
        while (\(). isNothing (get resultRef)) \().
          case body (get i) (get carryRef) of
            Continue carry ->
              i := get i + 1
              carryRef := carry
            Done result ->
              resultRef := Just result
  case result of
    Just ans -> ans
    Nothing -> todo  -- should be unreachable

-- returns the highest index `i` such that `xs.i <= x`
def searchSorted (_:Ord a) ?=> (xs:n=>a) (x:a) : Maybe n =
  case size n == 0 of
    True -> Nothing
    False -> case x < xs.(fromOrdinal _ 0) of
      True -> Nothing
      False ->
        iter (0, size n) \_ (low, high).
          numLeft = high - low
          case numLeft == 1 of
            True -> Done $ Just $ fromOrdinal _ low
            False ->
              centerIx = low + idiv (high - low) 2
              case x < xs.(fromOrdinal _ centerIx) of
                True  -> Continue (low, centerIx)
                False -> Continue (centerIx, high)

def applyN (n:Int) (x:a) (f:a -> a) : a =
  snd $ withState x \ref. for _:(Fin n).
    ref := f (get ref)

def linspace (n:Type) (low:Float) (high:Float) : n=>Float =
  dx = (high - low) / IToF (size n)
  for i:n. low + IToF (ordinal i) * dx

def transpose (x:n=>m=>Float) : m=>n=>Float = for i j. x.j.i
def vdot (x:n=>Float) (y:n=>Float) : Float = fsum \i. x.i * y.i

-- matmul. Better symbol to use? `@`?
(**) : (l=>m=>Float) -> (m=>n=>Float) -> (l=>n=>Float) = \x y.
  y' = transpose y
  for i k. fsum \j. x.i.j * y'.k.j

(**.) : (n=>m=>Float) -> (m=>Float) -> (n=>Float) = \mat v. for i. vdot mat.i v
(.**) : (m=>Float) -> (n=>m=>Float) -> (n=>Float) = flip (**.)

def inner (x:n=>Float) (mat:n=>m=>Float) (y:m=>Float) : Float =
  fsum \(i,j). x.i * mat.i.j * y.j

'min / max etc

def minBy (_:Ord o) ?=> (f:a->o) (x:a) (y:a) : a = select (f x < f y) x y
def maxBy (_:Ord o) ?=> (f:a->o) (x:a) (y:a) : a = select (f x > f y) x y

def min (_:Ord o) ?=> (x1: o) -> (x2: o) : o = minBy id x1 x2
def max (_:Ord o) ?=> (x1: o) -> (x2: o) : o = maxBy id x1 x2

def minimumBy (_:Ord o) ?=> (f:a->o) (xs:n=>a) : a =
  reduce xs.(0@_) (minBy f) xs
def maximumBy (_:Ord o) ?=> (f:a->o) (xs:n=>a) : a =
  reduce xs.(0@_) (maxBy f) xs

def minimum (_:Ord o) ?=> (xs:n=>o) : o = minimumBy id xs
def maximum (_:Ord o) ?=> (xs:n=>o) : o = maximumBy id xs

def argmin (_:Ord o) ?=> (xs:n=>o) : n =
  zeroth = (0@_, xs.(0@_))
  compare = \(idx1, x1) (idx2, x2).
    select (x1 < x2) (idx1, x1) (idx2, x2)
  zipped = for i. (i, xs.i)
  fst $ reduce zeroth compare zipped

'Functions for working with the pseudorandom number generator

-- TODO: newtype
Key = Int64

def hash (x:Key) (y:Int) : Key =
  y64 = IToI64 y
  %ffi threefry2x32 Int64 x y64
def newKey (x:Int) : Key = hash (IToI64 0) x
def splitKey (k:Key) : (Key & Key) = (hash k 0, hash k 1)
def splitKey3 (k:Key) : (Key & Key & Key) =
  (k1, k') = splitKey k
  (k2, k3) = splitKey k'
  (k1, k2, k3)

def many (f:Key->a) (k:Key) (i:n) : a = f (hash k (ordinal i))
def ixkey (k:Key) (i:n) : Key = hash k (ordinal i)
def ixkey2 (k:Key) (i:n) (j:m) : Key = hash (hash k (ordinal i)) (ordinal j)
def rand (k:Key) : Float = F64ToF $ %ffi randunif Float64 k
def randVec (n:Int) (f: Key -> a) (k: Key) : Fin n => a =
  for i:(Fin n). f (ixkey k i)

def randn (k:Key) : Float =
  (k1, k2) = splitKey k
  u1 = rand k1
  u2 = rand k2
  sqrt ((-2.0) * log u1) * cos (2.0 * pi * u2)

def randIdx (n:Type) ?-> (k:Key) : n =
  unif = rand k
  fromOrdinal n $ FToI $ floor $ unif * IToF (size n)

def bern (p:Float) (k:Key) : Bool = rand k < p

def randnVec (n:Type) ?-> (k:Key) : n=>Float =
  for i. randn (ixkey k i)

def cumSum (xs: n=>Float) : n=>Float =
  fst $ withState 0.0 \total.
    for i.
      newTotal = get total + xs.i
      total := newTotal
      newTotal

def cumSumLow (xs: n=>Float) : n=>Float =
  fst $ withState 0.0 \total.
    for i.
      oldTotal = get total
      total := oldTotal + xs.i
      oldTotal

-- cdf should include 0.0 but not 1.0
def categoricalFromCDF (cdf: n=>Float) (key: Key) : n =
  r = rand key
  case searchSorted cdf r of
    Just i -> i

def normalizePdf (xs: d=>Float) : d=>Float = xs / sum xs

def cdfForCategorical (logprobs: n=>Float) : n=>Float =
  maxLogProb = maximum logprobs
  cumSumLow $ normalizePdf $ map exp $ for i. logprobs.i - maxLogProb

def categorical (logprobs: n=>Float) (key: Key) : n =
  categoricalFromCDF (cdfForCategorical logprobs) key

-- batch variant to share the work of forming the cumsum
-- (alternatively we could rely on hoisting of loop constants)
def categoricalBatch (logprobs: n=>Float) (key: Key) : m=>n =
  cdf = cdfForCategorical logprobs
  for i. categoricalFromCDF cdf $ ixkey key i

'Automatic differentiation

-- TODO: add vector space constraints
def linearize (f:a->b) (x:a) : (b & a --o b) = %linearize f x
def jvp (f:a->b) (x:a) : a --o b = snd (linearize f x)
def transposeLinear (f:a --o b) : b --o a = %linearTranspose f

def vjp (f:a->b) (x:a) : (b & b --o a) =
  (y, df) = linearize f x
  (y, transposeLinear df)

def grad (f:a->Float) (x:a) : a = snd (vjp f x) 1.0

def deriv (f:Float->Float) (x:Float) : Float = jvp f x 1.0

def derivRev (f:Float->Float) (x:Float) : Float = snd (vjp f x) 1.0

def checkDerivBase (f:Float->Float) (x:Float) : Bool =
  -- TODO: parse 1e-5
  eps = 0.00005
  ansFwd  = deriv    f x
  ansRev  = derivRev f x
  ansNumeric = (f (x + eps) - f (x - eps)) / (2. * eps)
  isClose = \a b. abs (a - b) < 0.001
  isClose ansFwd ansNumeric && isClose ansRev ansNumeric

def checkDeriv (f:Float->Float) (x:Float) : Bool =
  checkDerivBase f x && checkDerivBase (deriv f) x

'Vector support

-- TODO: Reenable vector suport once fixed-width types are supported.
-- def UNSAFEFromOrdinal (n : Type) (i : Int) : n = %unsafeAsIndex n i
--
-- VectorWidth = 4  -- XXX: Keep this synced with the constant defined in Array.hs
-- VectorFloat  = todo
--
-- def packVector (a : Float) (b : Float) (c : Float) (d : Float) : VectorFloat = %vectorPack a b c d
-- def indexVector (v : VectorFloat) (i : Fin VectorWidth) : Float = %vectorIndex v i
--
-- -- NB: Backends should be smart enough to optimize this to a vector load from v
-- def loadVector (v : (Fin VectorWidth)=>Float) : VectorFloat =
--   idx = Fin VectorWidth
--   (packVector v.(UNSAFEFromOrdinal idx 0)
--               v.(UNSAFEFromOrdinal idx 1)
--               v.(UNSAFEFromOrdinal idx 2)
--               v.(UNSAFEFromOrdinal idx 3))
-- def storeVector (v : VectorFloat) : (Fin VectorWidth)=>Float =
--   idx = Fin VectorWidth
--   [ indexVector v (UNSAFEFromOrdinal idx 0)
--   , indexVector v (UNSAFEFromOrdinal idx 1)
--   , indexVector v (UNSAFEFromOrdinal idx 2)
--   , indexVector v (UNSAFEFromOrdinal idx 3) ]
--
-- def broadcastVector (v : Float) : VectorFloat = packVector v v v v
--
-- @instance vectorFloatAdd : Add VectorFloat =
--   (MkAdd ( \x y. %vfadd x y )
--          ( \x y. %vfsub x y )
--          ( broadcastVector zero ))
-- @instance vectorFloatMul : Mul VectorFloat =
--   MkMul (\x y. %vfmul x y) $ packVector 1.0 1.0 1.0 1.0
-- @instance vectorFloatVSpace : VSpace VectorFloat =
--   MkVSpace vectorFloatAdd \x v. broadcastVector x * v

'Tiling

def Tile (n : Type) (m : Type) : Type = %IndexSlice n m

-- One can think of instances of `Tile n m` as injective functions `m -> n`,
-- with the special property that consecutive elements of m map to consecutive
-- elements of n. In this view (+>) is just function application, while ++>
-- is currying followed by function application. We cannot represent currying
-- in isolation, because `Tile n (Tile u v)` does not make sense, unlike `Tile n (u & v)`.
def (+>) (l : Type) ?-> (t:Tile n l) (i : l) : n = %sliceOffset t i
def (++>) (t : Tile n (u & v)) (i : u) : Tile n v = %sliceCurry t i

def tile  (l : Type) ?->
          (fTile : (t:(Tile n l) -> {|eff} l=>a))
          (fScalar : n -> {|eff} a) : {|eff} n=>a = %tiled fTile fScalar
def tile1 (n : Type) ?-> (l : Type) ?-> (m : Type) ?->
          (fTile : (t:(Tile n l) -> {|eff} m=>l=>a))
          (fScalar : n -> {|eff} m=>a) : {|eff} m=>n=>a = %tiledd fTile fScalar

-- TODO: This should become just `loadVector $ for i. arr.(t +> i)`
--       once we are able to eliminate temporary arrays. Until then, we inline for performance...
--def loadTile (t : Tile n (Fin VectorWidth)) (arr : n=>Float) : VectorFloat =
--  idx = Fin VectorWidth
--  (packVector arr.(t +> UNSAFEFromOrdinal idx 0)
--              arr.(t +> UNSAFEFromOrdinal idx 1)
--              arr.(t +> UNSAFEFromOrdinal idx 2)
--              arr.(t +> UNSAFEFromOrdinal idx 3))

'Numerical utilities

def logsumexp (x: n=>Float) : Float =
  m = maximum x
  m + (log $ sum for i. exp (x.i - m))

def logsoftmax (x: n=>Float) : n=>Float =
  lse = logsumexp x
  for i. x.i - lse

def softmax (x: n=>Float) : n=>Float =
  m = maximum x
  e =  for i. exp (x.i - m)
  s = sum e
  for i. e.i / s

def evalpoly (_:VSpace v) ?=> (coefficients:n=>v) (x:Float) : v =
  -- Evaluate a polynomial at x.  Same as Numpy's polyval.
  fold zero \i c. coefficients.i + x .* c

data List a:Type =
  AsList n:Int foo:(Fin n => a)

def (<>) (x:List a) (y:List a) : List a =
  (AsList nx xs) = x
  (AsList ny ys) = y
  nz = nx + ny
  AsList _ $ for i:(Fin nz).
    i' = ordinal i
    case i' < nx of
      True  -> xs.(fromOrdinal _ i')
      False -> ys.(fromOrdinal _ (i' - nx))
